{"meta":{"title":"Jingyu_Blog","subtitle":"","description":"永无止境","author":"Jingyu","url":"https://jingyu.life","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-08-27T02:26:55.727Z","updated":"2020-07-03T17:55:10.842Z","comments":true,"path":"404.html","permalink":"https://jingyu.life/404","excerpt":"","text":""},{"title":"分类","date":"2020-06-20T08:39:54.000Z","updated":"2020-06-30T09:18:16.367Z","comments":false,"path":"categories/index.html","permalink":"https://jingyu.life/categories/","excerpt":"","text":""},{"title":"这里我是我整理的书籍","date":"2020-06-19T16:00:00.000Z","updated":"2020-07-07T07:28:54.931Z","comments":false,"path":"books/index.html","permalink":"https://jingyu.life/books/","excerpt":"","text":"技术类 《Head First 设计模式》-- [美] 弗里曼 文学类 《失控：全人类的最终命运和结局》-- 凯文·凯利 《自卑与超越》-- (奥地利)阿弗雷德·阿德勒"},{"title":"标签","date":"2020-06-20T08:40:08.000Z","updated":"2020-07-01T07:37:27.164Z","comments":false,"path":"tags/index.html","permalink":"https://jingyu.life/tags/","excerpt":"","text":""},{"title":"我就是我, 我如我是","date":"2020-06-20T06:03:26.000Z","updated":"2020-07-29T07:51:10.206Z","comments":false,"path":"about/index.html","permalink":"https://jingyu.life/about/","excerpt":"","text":"关于我 ​ 搭建自己的博客， 现在最简单的目的就是记录一些工作中遇到的问题和自己的所思所感。 ​ 学习，永无止境。学习的过程，是自己独立思考和解决问题相统一的。 ​ 我是Jingyu， 努力成为一名优秀的工程师。 所谓顺其自然，有时不过是自欺欺人， 唯有竭尽全力，方能不负初心。 努力不一定带来成功， 但一定会带来成长。 不能铭记过去的人，注定要重蹈覆辙。 加油吧， 骚年！ 时间轴 2020 06/20 搭建自己的博客 05/20 20考研复试落水， 迷茫中 2019 06/30 离职, 参加20考研 2018 06/25 北京极宇周天， 正式入职 06/13 学校毕业，出发北京"},{"title":"友链","date":"2020-06-25T07:08:13.000Z","updated":"2020-07-04T20:09:05.060Z","comments":false,"path":"friends/index.html","permalink":"https://jingyu.life/friends/","excerpt":"","text":""}],"posts":[{"title":"mysql中的时间函数以及格式问题","slug":"mysql/time-func","date":"2020-09-12T05:54:54.000Z","updated":"2020-09-14T08:33:36.249Z","comments":false,"path":"2020/09/12/mysql/time-func/","link":"","permalink":"https://jingyu.life/2020/09/12/mysql/time-func/","excerpt":"之前在开发过程中， 碰到数据库关于时间的问题，总是要去搜索一下， 自己简单记录一下常用的吧，后面遇到啥新鲜的玩意， 再加上。","text":"之前在开发过程中， 碰到数据库关于时间的问题，总是要去搜索一下， 自己简单记录一下常用的吧，后面遇到啥新鲜的玩意， 再加上。 时间函数 获取当前日期和时间mysql&gt; SELECT CURDATE(), CURRENT_DATE, CURTIME(), CURRENT_TIME;+------------+--------------+-----------+--------------+| CURDATE() | CURRENT_DATE | CURTIME() | CURRENT_TIME |+------------+--------------+-----------+--------------+| 2020-09-14 | 2020-09-14 | 14:34:00 | 14:34:00 |+------------+--------------+-----------+--------------+mysql&gt; SELECT NOW(), CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP;+---------------------+---------------------+---------------------+| NOW() | CURRENT_TIMESTAMP() | CURRENT_TIMESTAMP |+---------------------+---------------------+---------------------+| 2020-09-14 14:35:23 | 2020-09-14 14:35:23 | 2020-09-14 14:35:23 |+---------------------+---------------------+---------------------+-- 获取系统时间mysql&gt; SELECT SYSDATE();+---------------------+| SYSDATE() |+---------------------+| 2020-09-14 15:20:25 |+---------------------+ 获取当前时间的各个信息，如月份、一年第几周mysql&gt; SELECT WEEK(NOW()), WEEK(&#39;2020-01-01&#39;), DAY(CURRENT_TIMESTAMP()), DAY(&#39;2019-12-12 13:23:57&#39;), YEAR(NOW()), MONTH(NOW());+-------------+--------------------+--------------------------+----------------------------+-------------+--------------+| WEEK(NOW()) | WEEK(&#39;2020-01-01&#39;) | DAY(CURRENT_TIMESTAMP()) | DAY(&#39;2019-12-12 13:23:57&#39;) | YEAR(NOW()) | MONTH(NOW()) |+-------------+--------------------+--------------------------+----------------------------+-------------+--------------+| 37 | 0 | 14 | 12 | 2020 | 9 |+-------------+--------------------+--------------------------+----------------------------+-------------+--------------+ 关于时间戳转换mysql&gt; SELECT UNIX_TIMESTAMP(), UNIX_TIMESTAMP(&#39;2020-05-01 13:29:57&#39;), FROM_UNIXTIME(1600066964), FROM_UNIXTIME(1600066964, &#39;%m&#x2F;%d&#x2F;%Y&#39;);+------------------+---------------------------------------+---------------------------+---------------------------------------+| UNIX_TIMESTAMP() | UNIX_TIMESTAMP(&#39;2020-05-01 13:29:57&#39;) | FROM_UNIXTIME(1600066964) | FROM_UNIXTIME(1600066964, &#39;%m&#x2F;%d&#x2F;%Y&#39;) |+------------------+---------------------------------------+---------------------------+---------------------------------------+| 1600067106 | 1588310997 | 2020-09-14 15:02:44 | 09&#x2F;14&#x2F;2020 |+------------------+---------------------------------------+---------------------------+---------------------------------------+ 自己提取时间中的信息-- 格式 SELECT EXTRACT(unit FROM date)-- eg.SELECT EXTRACT((SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR|MICROSECOND|YEAR_DAY) FROM NOW())mysql&gt; select extract(MONTH FROM NOW()), EXTRACT(YEAR FROM &#39;2019-12-31&#39;), EXTRACT(YEAR_MONTH FROM &#39;2019-12-31&#39;);+---------------------------+---------------------------------+---------------------------------------+| extract(MONTH FROM NOW()) | EXTRACT(YEAR FROM &#39;2019-12-31&#39;) | EXTRACT(YEAR_MONTH FROM &#39;2019-12-31&#39;) |+---------------------------+---------------------------------+---------------------------------------+| 9 | 2019 | 201912 |+---------------------------+---------------------------------+---------------------------------------+ 日期运算-- DATE_ADD(date,INTERVAL expr type) 日期加上时间区间-- eg. DATE_ADD(now(), INTERVAL expr(YEAR|DAY|...|YEAR_MONTH|DAY_HOUR|DAY_MINUTE|DAY_SECOND|HOUR_SECOND))mysql&gt; SELECT DATE_ADD(&#39;2020-05-01 00:01:01&#39;, interval &#39;1 1:20:29&#39; day_second);+------------------------------------------------------------------+| DATE_ADD(&#39;2020-05-01 00:01:01&#39;, interval &#39;1 1:20:29&#39; day_second) |+------------------------------------------------------------------+| 2020-05-02 01:21:30 |+------------------------------------------------------------------+-- DATE_SUB(date,INTERVAL expr type) 日期减去时间区间mysql&gt; SELECT DATE_SUB(&#39;2020-05-02 01:21:30 &#39;, interval &#39;1 1:20:29&#39; day_second);+-------------------------------------------------------------------+| DATE_SUB(&#39;2020-05-02 01:21:30 &#39;, interval &#39;1 1:20:29&#39; day_second) |+-------------------------------------------------------------------+| 2020-05-01 00:01:01 |+-------------------------------------------------------------------+-- DATEDIFF(date1, date2) 日期相减mysql&gt; SELECT DATEDIFF(&#39;2020-05-03&#39;, &#39;2020-05-01&#39;), DATEDIFF(&#39;2020-05-03 12:23:33&#39;, &#39;2020-05-01 12:22:33&#39;);+--------------------------------------+--------------------------------------------------------+| DATEDIFF(&#39;2020-05-03&#39;, &#39;2020-05-01&#39;) | DATEDIFF(&#39;2020-05-03 12:23:33&#39;, &#39;2020-05-01 12:22:33&#39;) |+--------------------------------------+--------------------------------------------------------+| 2 | 2 |+--------------------------------------+--------------------------------------------------------+-- TIMEDIFF(time1, time2)-- 注意两个日期类型的相减，默认是0mysql&gt; SELECT TIMEDIFF(&#39;12:23:33&#39;, &#39;12:22:23&#39;),TIMEDIFF(&#39;2020-05-03&#39;, &#39;2020-05-01&#39;), TIMEDIFF(&#39;2020-05-03 12:23:33&#39;, &#39;2020-05-01 12:22:33&#39;);+----------------------------------+--------------------------------------+--------------------------------------------------------+| TIMEDIFF(&#39;12:23:33&#39;, &#39;12:22:23&#39;) | TIMEDIFF(&#39;2020-05-03&#39;, &#39;2020-05-01&#39;) | TIMEDIFF(&#39;2020-05-03 12:23:33&#39;, &#39;2020-05-01 12:22:33&#39;) |+----------------------------------+--------------------------------------+--------------------------------------------------------+| 00:01:10 | 00:00:00 | 48:01:00 |+----------------------------------+--------------------------------------+--------------------------------------------------------+ 时间格式转化 STR_TO_DATE()-- 将字符串格式的时间转化为日期类型-- STR_TO_DATE(str, format)mysql&gt; SELECT STR_TO_DATE(&#39;08,23,20&#39;, &#39;%m,%d,%y&#39;) , STR_TO_DATE(&#39;05&#x2F;21&#x2F;2020 12:23:33&#39;, &#39;%m&#x2F;%d&#x2F;%Y %H:%i:%s&#39;), STR_TO_DATE(&#39;21,5,2020 extra characters&#39;,&#39;%d,%m,%Y&#39;);+-------------------------------------+---------------------------------------------------------+------------------------------------------------------+| STR_TO_DATE(&#39;08,23,20&#39;, &#39;%m,%d,%y&#39;) | STR_TO_DATE(&#39;05&#x2F;21&#x2F;2020 12:23:33&#39;, &#39;%m&#x2F;%d&#x2F;%Y %H:%i:%s&#39;) | STR_TO_DATE(&#39;21,5,2020 extra characters&#39;,&#39;%d,%m,%Y&#39;) |+-------------------------------------+---------------------------------------------------------+------------------------------------------------------+| 2020-08-23 | 2020-05-21 12:23:33 | 2020-05-21 |+-------------------------------------+---------------------------------------------------------+------------------------------------------------------+-- 看看格式化值为NULL的例子mysql&gt; SELECT STR_TO_DATE(&#39;2020&#39;,&#39;%Y&#39;), STR_TO_DATE(&#39;202005&#39;, &quot;%Y%m&quot;) , STR_TO_DATE(&#39;11&#39;, &#39;%h&#39;), STR_TO_DATE(&#39;122223&#39;, &#39;%H%i%s&#39;);+--------------------------+-------------------------------+-------------------------+---------------------------------+| STR_TO_DATE(&#39;2020&#39;,&#39;%Y&#39;) | STR_TO_DATE(&#39;202005&#39;, &quot;%Y%m&quot;) | STR_TO_DATE(&#39;11&#39;, &#39;%h&#39;) | STR_TO_DATE(&#39;122223&#39;, &#39;%H%i%s&#39;) |+--------------------------+-------------------------------+-------------------------+---------------------------------+| NULL | NULL | NULL | NULL |+--------------------------+-------------------------------+-------------------------+---------------------------------+ DATE_FROMAT()-- 将标准格式转化为自己想要的格式-- DATE_FORMAT(date, format)mysql&gt; SELECT DATE_FORMAT(now(), &#39;%m&#x2F;%d&#x2F;%Y&#39;), DATE_FORMAT(&#39;2019-05-01 12:22:33&#39;, &#39;%m,%d,%Y, %H-%i-%s&#39;);+--------------------------------+----------------------------------------------------------+| DATE_FORMAT(now(), &#39;%m&#x2F;%d&#x2F;%Y&#39;) | DATE_FORMAT(&#39;2019-05-01 12:22:33&#39;, &#39;%m,%d,%Y, %H-%i-%s&#39;) |+--------------------------------+----------------------------------------------------------+| 09&#x2F;14&#x2F;2020 | 05,01,2019, 12-22-33 |+--------------------------------+----------------------------------------------------------+","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"Mysql","slug":"开发/mysql","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/mysql/"}],"tags":[{"name":"Mysql","slug":"mysql","permalink":"https://jingyu.life/tags/mysql/"}]},{"title":"git 子模块","slug":"git-submodule","date":"2020-08-26T09:57:39.000Z","updated":"2020-08-27T03:45:41.801Z","comments":false,"path":"2020/08/26/git-submodule/","link":"","permalink":"https://jingyu.life/2020/08/26/git-submodule/","excerpt":"经常碰到这种情况：当你在一个Git 项目上工作时，你需要在其中使用另外一个Git 项目。也许它是一个第三方开发的Git 库或者是你独立开发和并在多个父项目中使用的。这个情况下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。 这时候 submodule 就上场了！","text":"经常碰到这种情况：当你在一个Git 项目上工作时，你需要在其中使用另外一个Git 项目。也许它是一个第三方开发的Git 库或者是你独立开发和并在多个父项目中使用的。这个情况下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。 这时候 submodule 就上场了！ 添加子模块# 直接clone，会在当前目录生成一个对应子目录存放仓库内容$ git submodule add &lt;submodule_url&gt; [path/submoduleName]# 初始化本地.gitmodules文件$ git submodule init # 同步远端submodule源码$ git submodule update # 获取主项目和所有子项目源码$ git clone --recurse-submodules &lt;main_project_url&gt; 查看 &amp; 更新# 查看子模块$ git submodule# 更新项目内子模块到最新版本$ git submodule update# 更新子模块为远程项目的最新版本$ git submodule update --remote 删除子模块# 1、 删除子模块文件夹$ git rm --cached &lt;submodule&gt;$ rm -rf &lt;submodule&gt;# 2、删除.gitmodules文件中相关子模块信息# 3、删除.git/config中的相关子模块信息# 4、删除.git文件夹中的相关子模块文件$ rm -rf .git/modules/&lt;submodule&gt; 同步 向上同步# 当子模块有未被使用的新提交时（例如在 sub-module.git 中执行 git pull --rebase 拉取新的内容后），git 会给予提示# 将子模块的内容同步到主仓库，只需要在主仓库中创建一个新的提交即可$ git add submodule$ git commit -m \"message\" 向下同步# 主要是更新$ git submodule update 注意点 当子模块有提交的时候,没有push到远程仓库, 父级引用子模块的commit更新,并提交到远程仓库, 当别人拉取代码的时候就会报出子模块的commit不存在 fatal: reference isn’t a tree 。 如果你仅仅引用了别人的子模块的游离分支,然后在主仓库修改了子仓库的代码,之后使用git submodule update拉取了最新代码,那么你在子仓库游离分支做出的修改会被覆盖掉。 我们假设你一开始在主仓库并没有采用子模块的开发方式,而是在另外的开发分支使用了子仓库,那么当你从开发分支切回到没有采用子模块的分支的时候,子模块的目录并不会被Git自动删除,而是需要你手动的删除了。","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Git","slug":"git","permalink":"https://jingyu.life/tags/git/"}]},{"title":"git学习篇","slug":"git-usage","date":"2020-08-09T05:54:54.000Z","updated":"2020-09-13T14:21:18.473Z","comments":false,"path":"2020/08/09/git-usage/","link":"","permalink":"https://jingyu.life/2020/08/09/git-usage/","excerpt":"本文不是记录所有的命令， 会将部分命令做一个简易说明 ​","text":"本文不是记录所有的命令， 会将部分命令做一个简易说明 ​ 看懂上面的流程， 就可以大致知道自己要进行什么操作，以及怎样操作 安装 安装的话， 自己搜一下吧， 问题应该不大 新建​ # 在当前目录下新建一个代码库 [新建一个目录， 初始化为代码库]$ git init [project-name]# 远程拷贝一个项目 , 克隆到本地$ git clone &lt;git-repo-url&gt; [project-name] 配置# 查看 config$ git config --list# 编辑 config$ git config -e [--global]# 修改用户信息$ git config [--global] user.name \"Your Name\"$ git config [--global] user.email \"email@example.com\"# 命令别名$ git config --global alias.st status$ git config --global alias.co checkout$ git config --global alias.ci commit# 个人喜欢将常用的 commit 简写为 ci， checkout简写为 co# --global 是全局配置， 不加上只能在对应的git 目录下使用 常用命令# 查看工作区和暂存区的状态$ git status # 将工作区的文件提交到暂存区$ git add . # 提交到本地仓库$ git commit -m \"本次提交说明\"# add和commit的合并，便捷写法（未追踪的文件无法直接提交到暂存区/本地仓库）$ git commit -am \"本次提交说明\" # 将本地分支和远程分支进行关联$ git push -u origin branchName # 将本地仓库的文件推送到远程分支$ git push# 拉取远程分支的代码$ git pull origin branchName # 合并分支$ git merge branchName # 查看本地拥有哪些分支$ git branch# 查看所有分支（包括远程分支和本地分支）$ git branch -a # 切换分支$ git checkout branchName # 临时将工作区文件的修改保存至堆栈中, 我个人是不太喜欢用stash的， 习惯是切换到另一个分支，保存结点。 毕竟不小心# 删除 stash中的内容， 找回也挺麻烦的$ git stash# 将之前保存至堆栈中的文件取出来$ git stash pop 其它命令## rm# 删除暂存区和工作区的文件$ git rm [filename]# 只删除暂存区的文件，不会删除工作区的文件, 停止追踪文件(后面将其添加至gitignore)$ git rm --cached [filename]## commit# 补充提交, 提交至上一个结点中$ git commit --amend [message] $ git commit --amend -no-edit# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]## push &amp; pull &amp; fetch# 将本地仓库的文件推送到远程分支# 如果远程仓库没有这个分支，会新建一个同名的远程分支# 如果省略远程分支名，则表示两者同名$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 拉取并合并项目其他人员的一个分支 $ git pull origin branchname # 等同于 fetch + merge$ git fetch origin branchName$ git merge origin/branchName# 强推， 覆盖远程结点$ git push -f## branch# 查看本地分支[-r 远程， -a 本地和远程]$ git branch [-r, -a]# 新建分支, 可以指向某个提交结点$ git branch &lt;branchName&gt; [commit]# 切换分支$ git checkout &lt;branchName&gt;# 新建并切换$ git checkout -b &lt;branchName&gt;# 删除分支# 删除本地 [-d 被删除的分支上有没有合并的结点会阻止, -D 强制删除分支 ]$ git branch [-d, -D] &lt;branchName&gt;# 删除远程分支$ git push &lt;远程主机名&gt; :&lt;远程分支名&gt;$ git push &lt;远程主机名&gt; --delete &lt;远程分支名&gt;$ git branch -dr &lt;remote/branch&gt;## diff# 查看工作区和暂存区所有文件的对比[单个文件的对比]$ git diff [fileName]# 1.你修改了某个文件，但是没有提交到暂存区，这时候会有对比的内容# 一旦提交到暂存区，就不会有对比的内容(因为暂存区已经更新)# 2.如果你新建了一个文件，但是没有提交到暂存区，这时候 diff 是没有结果的# 查看暂存区与上次提交到本地仓库的快照（即最新提交到本地仓库的快照）的对比$ git diff --cached/--staged# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 查看本地两个分支的所有的对比[单个文件的对比]$ git diff &lt;branchName1&gt; &lt;branchName2&gt; [fileName]# 查看远程分支和远程分支[本地分支]的对比 或 单个文件$ git diff &lt;远程主机名/branchname1&gt; &lt;远程主机名/branchname2 | branchname2&gt; [filenName]# 查看两个 commit 的对比$ git diff commit1 commit2 # 一个有意思的命令, 查看自己写了多少代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"## blame 谁动了你的面包, 甩锅大法# 显示指定文件是什么人在什么时间修改过$ git blame [fileName]## log# 查看提交历史$ git log --oneline --grep=\"关键字\" --graph --all --author \"username\" --reverse -num -p --before= 1 day/1 week/1 \"2019-06-06\" --after= \"2019-06-06\" --stat --abbrev-commit --pretty=format:\"xxx\" # oneline -&gt; 将日志记录一行一行的显示# grep=\"关键字\" -&gt; 查找日志记录中(commit提交时的注释)与关键字有关的记录# graph -&gt; 记录图形化显示 ！！！ # all -&gt; 将所有记录都详细的显示出来# author \"username\" -&gt; 查找这个作者提交的记录# reverse -&gt; commit 提交记录顺序翻转 # before -&gt; 查找规定的时间(如:1天/1周)之前的记录 # num -&gt; git log -10 显示最近10次提交 ！！！ # stat -&gt; 显示每次更新的文件修改统计信息，会列出具体文件列表 ！！！# abbrev-commit -&gt; 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 ！！！# pretty=format:\"xxx\" -&gt; 可以定制要显示的记录格式 ！！！# p -&gt; 显示每次提交所引入的差异（按 补丁 的格式输出）！！！# 常用$ git log --graph [--stat]# 查看本地 git 命令历史, 常用来恢复某些失误的操作$ git reflog## show# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]## tag# 列出所有tag$ git tag# 新建一个tag在指定commit, 可以指定说明文字$ git tag [tag] [commit] [-m \"message\"]# 查看单个标签具体信息$ git show &lt;tagname&gt;# 推送一个本地标签$ git push &lt;远程主机名&gt; &lt;tagname&gt;# 推送全部未推送过的本地标签$ git push &lt;远程主机名&gt; --tags# 删除本地tag$ git tag -d [tag]# 删除远程tag, 有点像删除远程分支$ git push &lt;远程主机名&gt; :refs/tags/&lt;tagname&gt; ## remote# 查看所有远程主机$ git remote# 查看关联的远程仓库的详细信息$ git remote -v # 删除远程仓库的 “关联”$ git remote rm &lt;远程主机名&gt; # 添加远程仓库的 “关联”$ git remote add &lt;远程主机名&gt; &lt;remote-url&gt;# 设置远程仓库的 “关联”$ git remote set-url &lt;远程主机名&gt; &lt;newurl&gt; 单读讲讲 分支合并 merge # 将另外一个分支合并到当前分支，主要是合并到master$ git merge &lt;branchName&gt; [--fast-forward | --no-ff | --squash]# --fast-forward: 会在当前分支的提交历史中添加进被合并分支的提交历史# --no-ff: 会生成一个新的提交，让当前分支的提交历史不会那么乱# --squash: 不会生成新的提交，会将被合并分支多次提交的内容直接存到工作区和暂存区，由开发者手动去提交，这样当前分支最终只会多出一条提交记录，不会掺杂被合并分支的提交历史 rebase 关于rebase 的示意图， 看看这篇文章吧 # 将master分支中的修改添加到master分支上(保证当前分支的修改， 是基于master分支上的修改)$ git checkout &lt;branchName&gt;$ git rebase master# 或者直接使用$ git rebase &lt;branchName1&gt; &lt;branchName2&gt;# 对当前分支提交的 startpoint -&gt; endpoint (前开后闭) 提交记录进行整理$ git rebase -i [startpoint] [endpoint]# pick：保留该commit（缩写:p）# reword：保留该commit，但我需要修改该commit的注释（缩写:r）# edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）# squash：将该commit和前一个commit合并（缩写:s）# fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）# exec：执行shell命令（缩写:x）# drop：我要丢弃该commit（缩写:d）# 选择特定的结点到指定分支(区间前开后闭), 建议使用 cherry-pick$ git rebase [startpoint] [endpoint] --onto master# 注意: 添加过去的结点， 还处于游离状态(HEAD没有处于最新结点) ， 可以新建一个分支或直接使用 reset --hard cherry-pick # 将提交的结点 添加到当前分支，会产生一个新的提交(哈希值不一样)$ git cherry-pick &lt;commitHash&gt;# 将另外一个分支上最新提交的结点添加到当前分支$ git cherry-pick &lt;branchName&gt;# 转移多个提交$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;# 转移一系列提交（区间， 左开右闭）$ git cherry-pick &lt;HashA&gt;^..&lt;HashB&gt; 关于cherry-pick, 参考这里 撤销&amp;回退# 原来的命令# 撤销工作区修改的文件, 还未提交到暂存区$ git checkout filname# 撤销暂存区的文件$ git reset HEAD filename## checkout# 恢复暂存区的指定文件到工作区$ git checkout &lt;filename&gt;# 恢复暂存区的所有文件到工作区$ git checkout .# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 检出结点, 标签$ git checkout[&lt;commitid&gt; | &lt;tag&gt;]## reset# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变, 软回退$ git reset [commit]# 重置暂存区与工作区，与上一次commit保持一致, 硬回退$ git reset --hard [commit]## revert# 生成一个撤销指定提交版本的新提交$ git revert &lt;commit_id&gt;# 新命令## restore &amp; switch# 主要还是为了分离 checkout的功能# 切换分支 = git checkout &lt;branchName&gt;$ git switch &lt;branchName&gt;# 创建并切换到新建分支 = git checkout -b &lt;newbranch&gt;$ git switch -c &lt;newBranch&gt;# 撤销工作区修改的文件 = git checkout &lt;fileName&gt;$ git restore &lt;fileName&gt;# 撤销暂存区的文件 = git reset &lt;fileName&gt;$ git restore --staged &lt;fileName&gt;","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Git","slug":"git","permalink":"https://jingyu.life/tags/git/"}]},{"title":"Docker 进阶篇之Compose","slug":"docker/compose","date":"2020-08-02T15:11:19.000Z","updated":"2020-08-09T05:49:57.401Z","comments":false,"path":"2020/08/02/docker/compose/","link":"","permalink":"https://jingyu.life/2020/08/02/docker/compose/","excerpt":"Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。","text":"Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。 简介Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。 Compose代码目前在 https://github.com/docker/compose 上开源。 安装与卸载 安装 Mac/Windows Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。 Ubuntu 1、通过下载二进制包 $ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose 2、 pip安装 $ sudo pip install -U docker-compose 3、bash补全命令 $ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 卸载1、删除二进制包文件 $ sudo rm /usr/local/bin/docker-compose 2、pip移除 $ sudo pip uninstall docker-compose 使用以及说明 术语首先介绍几个术语。 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。 可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。 命令 基本格式$ docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...] 命令选项-f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 --x-networking 使用 Docker 的可拔插网络后端特性 --x-network-driver DRIVER 指定网络后端的驱动，默认为bridge --verbose 输出更多调试信息。 -v, --version 打印版本并退出。 build格式为 docker-compose build [options] [SERVICE...]。 构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。 选项包括： --force-rm 删除构建过程中的临时容器。 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。 --pull 始终尝试通过 pull 来获取更新版本的镜像。 config验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。 down此命令将会停止 up 命令所启动的容器，并移除网络 start格式为 docker-compose start [SERVICE...]。 启动已经存在的服务容器。 stop格式为 docker-compose stop [options] [SERVICE...]。 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时(默认为 10 秒)。 exec进入指定容器 images 列出 Compose 文件中包含的镜像。 kill 格式为 docker-compose kill [options] [SERVICE...]。 通过发送 SIGKILL 信号来强制停止服务容器。 logs 格式为 docker-compose logs [options] [SERVICE...]。 该命令在调试问题的时候十分有用。 pause 格式为 docker-compose pause [SERVICE...]。 暂停一个服务容器。 unpause格式为 docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 port格式为 docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 ps格式为 docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 pull格式为 docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 push推送服务依赖的镜像到 Docker 镜像仓库。 restart格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 rm格式为 docker-compose rm [options] [SERVICE...]。 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 选项： -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 run格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 选项： -d 后台运行容器。 --name NAME 为容器指定一个名字。 --entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=&quot;&quot; 指定运行容器的用户名或者 uid。 --no-deps 不自动启动关联的服务容器。 --rm 运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] 映射容器端口到本地主机。 --service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 scale格式为 docker-compose scale [options] [SERVICE=NUM...]。 设置指定服务运行的容器个数。 # 通过 service=num 的参数来设置数量$ docker-compose scale web=3 db=2# 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 top查看各个服务容器内运行的进程。 up格式为 docker-compose up [options] [SERVICE...]。 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。 默认情况，docker-compose up 启动的容器都在前台，docker-compose up -d(生产环境下使用)，将会在后台启动并运行所有的容器。 如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate, 只会启动处于停止状态的容器，而忽略已经运行的服务; 如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 选项： -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 version格式为 docker-compose version。 打印版本信息。 Compose 模板文件 ​ 大部分指令跟 docker run 相关参数的含义都是类似的。默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。 每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。 build指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径） Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 version: '3'services: webapp: build: ./dir 也可以使用context 指令指定 Dockerfile 所在文件夹的路径， dockerfile 指令指定 Dockerfile 文件名， arg 指令指定构建镜像时的变量 version: '3'services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 cache_from 指定构建镜像的缓存 build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop指定容器的内核能力（capacity）分配 command覆盖容器启动后默认执行的命令。 command: echo \"hello world\" cgroup_parent指定父 cgroup 组，意味着将继承该组的资源限制。 # 创建了一个 cgroup 组名称为 cgroups_1cgroup_parent: cgroups_1 container_name指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 devices指定设备映射关系。 devices: - \"/dev/ttyUSB1:/dev/ttyUSB0\" depends_on解决容器的依赖、启动先后的问题。 version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 例子中会先启动 redis db 再启动 web , web 服务不会等待 redis db 「完全启动」之后才启动。 dns自定义 DNS 服务器。可以是一个值，也可以是一个列表。 dns: 8.8.8.8dns: - 8.8.8.8 - 114.114.114.114 dns_search配置 DNS 搜索域。可以是一个值，也可以是一个列表。 dns_search: example.comdns_search: - domain1.example.com - domain2.example.com tmpfs挂载一个 tmpfs 文件系统到容器。 tmpfs: /runtmpfs: - /run - /tmp env_file从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env environment设置环境变量。可以使用数组或字典两种格式。 environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET expose暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数 expose: - \"3000\" - \"8000\" extra_hosts指定额外的 host 名称映射信息 extra_hosts: - \"googledns:8.8.8.8\" - \"dockerhub:52.1.157.61\" 会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。 8.8.8.8 googledns52.1.157.61 dockerhub image指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd labels为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 labels: com.startupteam.description: \"webapp for a startup team\" com.startupteam.department: \"devops department\" com.startupteam.release: \"rc3 for v1.0\" logging配置日志选项。 logging: # 目前支持三种日志驱动类型 json-file syslog none driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" # options: # max-size: \"200k\" # max-file: \"10\" network_mode设置网络模式。使用和 docker run 的 --network 参数一样的值。 network_mode: \"bridge\"network_mode: \"host\"network_mode: \"none\"network_mode: \"service:[service name]\"network_mode: \"container:[container name/id]\" networks配置容器连接的网络。 version: \"3\"services: some-service: networks: - some-network - other-networknetworks: some-network: other-network: pid跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。 pid: \"host\" ports暴露端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" volumes数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式 （HOST:CONTAINER:ro）。 volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro 如果路径为数据卷名称，必须在文件中配置数据卷。 version: \"3\"services: my_src: image: mysql:8.0 volumes: - mysql_data:/var/lib/mysqlvolumes: mysql_data:","categories":[{"name":"运维","slug":"运维","permalink":"https://jingyu.life/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://jingyu.life/tags/docker/"}]},{"title":"Docker 基础篇","slug":"docker/basic","date":"2020-07-31T08:40:08.000Z","updated":"2020-08-01T09:22:24.592Z","comments":false,"path":"2020/07/31/docker/basic/","link":"","permalink":"https://jingyu.life/2020/07/31/docker/basic/","excerpt":"Docker是一种运行在Linux和Windows上的软件，用于创建、管理和编排容器","text":"Docker是一种运行在Linux和Windows上的软件，用于创建、管理和编排容器 安装 Ubuntu 移除旧版本 $ sudo apt-get remove docker \\ docker-engine \\ docker.io Apt 安装 # 安装https传输的软件包和ca证书$ sudo apt-get update$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common # 添加软件源的 GPG 密钥$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 官方源# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 向 source.list 中添加 Docker 软件源$ sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable\"# 官方源# $ sudo add-apt-repository \\# \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable\" Docker CE 安装、启动 # 安装$ sudo apt-get update$ sudo apt-get install docker-ce# 也可以通过脚本自动化安装$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun# $ sudo sh get-docker.sh --mirror AzureChinaCloud# 启动$ sudo systemctl enable docker$ sudo systemctl start docker 建立docker用户组 # 建立用户组$ sudo groupadd docker# 将当前用户添加到docker组$ sudo usermod -aG docker $USER MacOS HomeBrew $ brew cask install docker 手动下载安装 如果需要手动下载，请点击以下链接下载 Stable 或 Edge 版本的 Docker Desktop for Mac。 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间需要输入用户密码）。 镜像 搜索$ docker search ubuntu 获取镜像# 格式 docker (image) pull &lt;Registry&gt;/&lt;userName of Orgnization&gt;/&lt;Repository&gt;:&lt;Tag&gt;# eg$ docker pull ubuntu:latest 列举镜像# 列举格式 $ docker images &lt;repository&gt;:&lt;tag&gt;# filter 参数过滤， 列举所有tag 为latest的镜像 (dangling, before, since, label, reference)$ docker image ls --filter reference=\"*:latest\"# 格式化显示, 注意格式(大小写、标点)$ docker images --format \"&#123;&#123;.Repository&#125;&#125;: &#123;&#123;.Size&#125;&#125;\"$ docker image ls --format \"table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;\"# 删除悬虚镜像$ docker image prune 删除本地镜像# 删除格式， 其中镜像是镜像ID(长或短)、镜像名、镜像摘要$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]# 删除所有名为redis的镜像$ docker rmi $(docker image ls -q redis) 更新镜像当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 # 产看容器内的变化# 格式 docker diff &lt;容器ID或容器名&gt;$ docker diff webserver # 格式 $ docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] # 例如, 在nginx容器中修改内容后 $ docker commit \\ --author \"jingyucute@gmail.com\" \\ --message \"update content\" \\ webserver \\ nginx:v2 # 或者简写$ docker commit \\ -a=\"jingyucute@gmail.com\" \\ -m=\"update content\" \\ webserver \\ nginx:v2 # 产看镜像内的提交记录# 格式 docker history &lt;仓库名&gt;[:&lt;标签&gt;$ docker history nginx:v2 特别注意 docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。 使用Dockerfile制作镜像# 格式 docker build [选项] &lt;上下文路径/URL/-&gt;$ docker build -t &lt;repository&gt;:&lt;tag&gt; .# 直接从Git repo中构建$ docker build https://github.com/twang2218/gitlab-ce-zh.git# 用给定的 tar 压缩包构建， 下载后会自动解压$ docker build http://server/context.tar.gz# 标准输入构建$ docker build - &lt; context.tar.gz$ docker build - &lt; Dockerfile$ cat Dockerfile | docker build - 容器 查看# 查看正在运行的容器, 加上-a参数表示查看所有的容器(包括退出的)$ docker container ls [-a]$ docker ps [-a] 启动# 从镜像中创建并启动一个容器 , 参数自己查吧# 格式 docker &lt;container&gt; run [--options]# 交互式运行ubuntu容器# -i: 交互式操作。# -t: 终端。# ubuntu: ubuntu 镜像。# /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash$ docker run -it ubuntu --name myOS /bin/bash# 守护态运行一个容器 # 格式 docker &lt;container&gt; run -d $ docker run -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\"# 启动一个停止了的容器# 格式 docker &lt;container&gt; start &lt;Container-name-or-ID&gt;$ docker start myOS 重启# 格式 docker &lt;container&gt; restart &lt;Container-name-or-ID&gt;$ docker restart myOS 查看容器输出# 格式 docker &lt;container&gt; logs &lt;Container-name-or-ID&gt;$ docker logs myOS 停止# 格式 docker &lt;container&gt; stop &lt;Container-name-or-ID&gt;$ docker stop myOS 删除# 删除的容器不能是运行状态，可以先停止再删除, 也可以通过加上 -f 参数强删(不推荐)# 格式 docker container rm &lt;Container-name-or-ID&gt; [-f]$ docker rm &lt;Container-name-or-ID&gt;# 清楚所有停止状态的容器$ docker container prune 进入容器# 两种方式, 推荐使用方式二# 方式一 docker attach &lt;Container-name-or-ID&gt;# 这种方式退出终端，会导致容器停止$ docker attach myOS# 方式一 docker attach &lt;Container-name-or-ID&gt;# 这种方式退出终端，会导致容器停止$ docker attach myOS# 方式二 docker exec -it &lt;Container-name-or-ID&gt; bash# 这种方式退出终端，容器不会停止$ docker exec -it myOS bash Dockerfile参数说明 FROM所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 FROM nginx... RUNRUN 指令是用来执行命令行命令的。通常有两种形式： ​ shell格式 RUN &lt;命令&gt; (常用格式) RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html ​ exec格式 RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] . 这种形式好比函数调用 RUN [\"./test.php\", \"dev\", \"offline\"] # ====RUN ./test.php dev offline 注意 这里的RUN要尽量少， 多了会导致镜像臃肿， 因为镜像是按照层来构建的，一个RUN就是一层。所以可以使用 &amp;&amp; 来链接命令，使用 \\来换行 举个例子： FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\"RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install# ---------------------------------------------------------&gt; FROM debian:stretchRUN buildDeps='gcc libc6-dev make wget' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps COPYCOPY指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置 # 格式 COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;# COPY [--chown=&lt;user&gt;:&lt;group&gt;] [\"&lt;源路径1&gt;\",... \"&lt;目标路径&gt;\"] COPY hom?.txt /mydir/# 改变文件的所属用户和用户组 --chown=&lt;user&gt;:&lt;group&gt;COPY --chown=55:mygroup files* /mydir/ ADDADD 指令和 COPY 的格式和性质基本一致(同样需求下， 推荐使用COPY)。 ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD # 改变文件的所属用户和用户组 --chown=&lt;user&gt;:&lt;group&gt;ADD --chown=55:mygroup files* /mydir/ CMDCMD 指令的格式和 RUN 相似。 CMD 在docker run 时运行。 RUN 是在 docker build。 CMD也有两种形式 # shell 格式：CMD &lt;命令&gt;# exec 格式：CMD [\"可执行文件\", \"参数1\", \"参数2\"...]CMD echo $HOME# ====CMD [ \"sh\", \"-c\", \"echo $HOME\" ] Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。 # CMD service nginx start# 这个命令是将nginx作为后台服务来运行的， 应该写为一下形式CMD [\"nginx\", \"-g\", \"daemon off;\"] ENTRYPOINTENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。就可以理解为&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; # 格式 ENTRYPOINT [\"&lt;executeable&gt;\",\"&lt;param1&gt;\",\"&lt;param2&gt;\",...] ENV设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 # 格式 ENV &lt;key&gt; &lt;value&gt; # ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...ENV NODE_VERSION 7.2.0RUN curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\" \\ &amp;&amp; curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\" ARGARG 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。 # 格式 ARG &lt;参数名&gt;[=&lt;默认值&gt;] 该默认值可以在构建命令 docker build 中用 --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。 VOLUME容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 # 格式 VOLUME [\"&lt;路径1&gt;\", \"&lt;路径2&gt;\"...]# VOLUME &lt;路径&gt;VOLUME /data docker run -d -v mydata:/data 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 EXPOSEEXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 # 格式 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 # 格式 WORKDIR &lt;工作目录路径&gt; 谈一下误区 初学者将Dockerfile 等同于 Shell 脚本来书写，会出现一下错误 RUN cd /appRUN echo \"hello\" &gt; world.txt 将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。 原因: 在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器 每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 USREUSER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份(用户和用户组必须提前已经存在)。 # 格式 USER &lt;用户名&gt;[:&lt;用户组&gt;] -","categories":[{"name":"运维","slug":"运维","permalink":"https://jingyu.life/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://jingyu.life/tags/docker/"}]},{"title":"常用工具网址","slug":"tool-assistant","date":"2020-07-28T06:34:06.000Z","updated":"2020-08-01T09:03:11.670Z","comments":false,"path":"2020/07/28/tool-assistant/","link":"","permalink":"https://jingyu.life/2020/07/28/tool-assistant/","excerpt":"这里记录一些常用的工具、网址等等","text":"这里记录一些常用的工具、网址等等 网址 我告诉你 简易图标制作 svg简易制作 一个很有意思的小站 工具 Typora V2rayU","categories":[{"name":"工具","slug":"工具","permalink":"https://jingyu.life/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Helper","slug":"helper","permalink":"https://jingyu.life/tags/helper/"}]},{"title":"nvm 使用说明","slug":"nvm-usage","date":"2020-07-15T04:04:41.000Z","updated":"2020-07-31T09:16:57.957Z","comments":false,"path":"2020/07/15/nvm-usage/","link":"","permalink":"https://jingyu.life/2020/07/15/nvm-usage/","excerpt":"简介 Nvm （Node Version Manager） 是node.js 的版本管理器，用它可以方便的在机器上安装并维护多个node版本。","text":"简介 Nvm （Node Version Manager） 是node.js 的版本管理器，用它可以方便的在机器上安装并维护多个node版本。 1、安装和更新脚本安装 下载并执行 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash 或者 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash 然后配置环境变量，将下面的内容添加到配置文件(~/.bash_profile，~/.zshrc，~/.profile，或~/.bashrc) export NVM_DIR=\"$([ -z \"$&#123;XDG_CONFIG_HOME-&#125;\" ] &amp;&amp; printf %s \"$&#123;HOME&#125;/.nvm\" || printf %s \"$&#123;XDG_CONFIG_HOME&#125;/nvm\")\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm git 安装 1、克隆远程仓库到本地 先 cd ~ 切换到家目录， 然后执行git clone https://github.com/nvm-sh/nvm.git .nvm 2、进入到.nvm目录，切换到最近的版本 cd ~/.nvmgit checkout v0.35.3 3、 激活nvm bash nvm.sh 4、 配置环境变量，文件位置同上，导入内容如下 export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion nvm更新 1、切换到$NVM_DIR (上面在环境变量中配置过了) 2、拉取最新的提交节点 3、切换到最新的版本 4、激活新版本 可以直接在命令行中执行一下内容 ( cd \"$NVM_DIR\" git fetch --tags origin git checkout `git describe --abbrev=0 --tags --match \"v[0-9]*\" $(git rev-list --tags --max-count=1)`) &amp;&amp; bash \"$NVM_DIR/nvm.sh\" 2、相关使用# 查看已经安装的版本nvm ls# 查看可以安装的所有版本nvm ls-remote# 查看所有长期支持版本（LTS）nvm ls-remote --lts# 查看最新ltsnvm version-remote --lts nvm version-remote lts/erbium# 安装最新ltsnvm install --lts# 安装或卸载指定node版本nvm install v12.18.2 nvm uninstall v12.18.2# 使用nodenvm use v12.18.2# 设置或取消别名nvm alias product v12.18.2 nvm unalias product# 安装io.jsnvm install iojs# 查看node安装位置nvm which v12.18.2 本文参考地址 https://github.com/nvm-sh/nvm","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Nvm","slug":"nvm","permalink":"https://jingyu.life/tags/nvm/"},{"name":"Node","slug":"node","permalink":"https://jingyu.life/tags/node/"}]},{"title":"Typora快捷键使用(Mac)","slug":"typora-usage","date":"2020-06-24T16:00:00.000Z","updated":"2020-08-27T03:14:23.787Z","comments":false,"path":"2020/06/25/typora-usage/","link":"","permalink":"https://jingyu.life/2020/06/25/typora-usage/","excerpt":"简介 刚开始搭建自己的博客， 学习了一下Markdown语法和Typora，这里记录了一下相关快捷键的使用。","text":"简介 刚开始搭建自己的博客， 学习了一下Markdown语法和Typora，这里记录了一下相关快捷键的使用。 1、基本操作1.1 生成目录 语法 [toc] 效果图 [toc] 1.2 标题 语法 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 快捷键 Command + [1, 2, 3, 4, 5, 6] 分别对应几级标题 1.3 引用 语法 &gt; 引用内容1 &gt;&gt; 引用内容2 &gt;&gt; 引用内容3 快捷键 Command + Option + Q 效果图 引用内容1 引用内容2 引用内容3 1.4 文本居中 语法 &lt;center&gt;居中文本&lt;/center&gt; 效果图 居中文本 2 、code使用2.1 单行代码 语法 &#96;String str &#x3D; &quot;Hello Typora&quot;;&#96;&#96;&#96;String str &#x3D; &quot;Hello Typora&quot;;&#96;&#96; 效果图 String str = &quot;Hello Typora&quot;; 2.2 多行代码 语法 输入 ```[language] + enter或者 ``` + enter , 然后选择语言类型 快捷键 Command + Option + C 效果图 int a = 1;int b = 2;int c = 3;count&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;\", b=\"&lt;&lt;b&lt;&lt;\", c=\"&lt;&lt;c&lt;&lt;endl; 3、列表3.1 无序列表 语法 * (+) [space]- (+) [space]+ (+) [space] 快捷键 Command + Option + U 效果图 类别一 类别二 类别三 3.2 有序列表 语法 1. (+) [space]2. (+) [space]3. (+) [space] 快捷键 Command + Option + O 效果图 类别1 类别2 类别3 3.3 任务列表 语法 形式: - [ ] 文本 为未选中文本 - [x] 文本 为选中文本注意: -和[之间有空格, [和]之间有空格, ]和文本之间有空格 快捷键 Command + Option + X 效果图 钓鱼 编程 散步 游戏 电影 3.4 表格 语法 |姓名|性别|年龄|手机号||:---|:--:|:--:|:---:||张三|男|21|18975346876||李四|女|23|17789548964||王五|男|25|15876513546| 快捷键 Command + Option + T 效果图 姓名 性别 年龄 手机号 张三 男 21 18975346876 李四 女 23 17789548964 王五 男 25 15876513546 4、链接4.1 图片 语法 本地图片 直接拖进来 网络图片 ![杭州西湖.jpg](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593110861170&amp;di=6651925eaab36bfeb23347aa51a12cb7&amp;imgtype=0&amp;src=http%3A%2F%2Fa3.att.hudong.com%2F14%2F75%2F01300000164186121366756803686.jpg) 效果图 本地 网络 4.2 文本链接 语法 不显示链接网址 [百度](https:&#x2F;&#x2F;www.baidu.com) 只显示链接url &lt;https:&#x2F;&#x2F;www.baidu.com&gt; 快捷键 Command + K 效果图 不显示地址 百度 只显示url https://www.baidu.com 5、其它快捷键5.1 斜体 语法 *斜体文字1*_斜体文字2_ 快捷键 Command + I 效果图 斜体文字1 斜体文字2 5.2 粗体 语法 **粗体文字1**__粗体文字2__ 快捷键 Command + B 效果图 粗体文字1 粗体文字2 5.3 加粗斜体 语法 ***加粗斜体文字1***___加粗斜体文字2___ 效果图 加粗斜体文字1 加粗斜体文字2 5.4 下划线 语法 &lt;u&gt;下划线文字&lt;/u&gt; 快捷键 Command + U 效果图 下划线文字 5.5 删除线 语法 ~~删除文字~~ 快捷键 Control + Shift + ` 效果图 删除文字 5.6 分割线 语法 --- (+) [enter]*** (+) [enter] 快捷键 Command (+) Option (+) - 效果图 5.7 脚注 语法 Typora1[^1]Typora2[^2] 快捷键 Command + Option + R 效果图 Typora^1 Typora2^2 5.8 符号输入 语法 \\\\ 反斜线\\&#96; 反引号\\* 星号\\_ 底线\\&#123; \\&#125; 花括号\\[ \\] 方括号\\( \\) 括弧\\# 井字号\\+ 加号\\- 减号\\. 英文句点\\! 惊叹号 效果图 \\ 5.9 特殊字符 语法 &amp;copy; 版权 &amp;reg; 注册商标&amp;trade; 商标&amp;nbsp; 空格&amp; 和号&quot; 引号&amp;apos; 撇号&lt; 小于号&gt; 大于号&amp;ne; 不等号&amp;le; 小于等于&amp;ge; 大于等于&amp;cent; 分&amp;pound; 磅&amp;euro; 欧元&amp;yen; 元&amp;sect; 节&amp;times; 乘号&amp;divide; 除号&amp;plusmn; 正负号 效果图 &copy; &pound; &apos; &euro; 5.10 表情 语法 :smiley: 效果图 :smile: :unamused:","categories":[{"name":"工具","slug":"工具","permalink":"https://jingyu.life/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"typora","permalink":"https://jingyu.life/tags/typora/"},{"name":"MarkDown","slug":"markdown","permalink":"https://jingyu.life/tags/markdown/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"Mysql","slug":"开发/mysql","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/mysql/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"},{"name":"运维","slug":"运维","permalink":"https://jingyu.life/categories/%E8%BF%90%E7%BB%B4/"},{"name":"工具","slug":"工具","permalink":"https://jingyu.life/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Mysql","slug":"mysql","permalink":"https://jingyu.life/tags/mysql/"},{"name":"Git","slug":"git","permalink":"https://jingyu.life/tags/git/"},{"name":"Docker","slug":"docker","permalink":"https://jingyu.life/tags/docker/"},{"name":"Helper","slug":"helper","permalink":"https://jingyu.life/tags/helper/"},{"name":"Nvm","slug":"nvm","permalink":"https://jingyu.life/tags/nvm/"},{"name":"Node","slug":"node","permalink":"https://jingyu.life/tags/node/"},{"name":"Typora","slug":"typora","permalink":"https://jingyu.life/tags/typora/"},{"name":"MarkDown","slug":"markdown","permalink":"https://jingyu.life/tags/markdown/"}]}