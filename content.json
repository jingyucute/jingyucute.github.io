{"meta":{"title":"随手一记","subtitle":"","description":"永无止境","author":"Yaurora","url":"https://jingyu.life","root":"/"},"pages":[{"title":"我就是我, 我如我是","date":"2020-06-20T06:03:26.000Z","updated":"2020-07-29T07:51:10.206Z","comments":false,"path":"about/index.html","permalink":"https://jingyu.life/about/","excerpt":"","text":"关于我 ​ 搭建自己的博客， 现在最简单的目的就是记录一些工作中遇到的问题和自己的所思所感。 ​ 学习，永无止境。学习的过程，是自己独立思考和解决问题相统一的。 ​ 我是Jingyu， 努力成为一名优秀的工程师。 所谓顺其自然，有时不过是自欺欺人， 唯有竭尽全力，方能不负初心。 努力不一定带来成功， 但一定会带来成长。 不能铭记过去的人，注定要重蹈覆辙。 加油吧， 骚年！ 时间轴 2020 06&#x2F;20 搭建自己的博客 05&#x2F;20 20考研复试落水， 迷茫中 2019 06&#x2F;30 离职, 参加20考研 2018 06&#x2F;25 北京极宇周天， 正式入职 06&#x2F;13 学校毕业，出发北京"},{"title":"","date":"2023-02-21T15:48:57.768Z","updated":"2023-02-21T15:48:57.768Z","comments":true,"path":"404.html","permalink":"https://jingyu.life/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"categories","date":"2023-02-20T07:23:09.000Z","updated":"2023-02-21T14:35:27.351Z","comments":false,"path":"categories/index.html","permalink":"https://jingyu.life/categories/","excerpt":"false","text":""},{"title":"links","date":"2023-02-20T07:57:35.000Z","updated":"2023-02-20T10:17:42.695Z","comments":false,"path":"friends/index.html","permalink":"https://jingyu.life/friends/","excerpt":"false","text":""},{"title":"这里是我整理的书籍","date":"2020-06-19T16:00:00.000Z","updated":"2020-09-15T14:15:07.795Z","comments":false,"path":"books/index.html","permalink":"https://jingyu.life/books/","excerpt":"","text":"技术类 《Head First 设计模式》– [美] 弗里曼 文学类 《失控：全人类的最终命运和结局》– 凯文·凯利 《自卑与超越》– (奥地利)阿弗雷德·阿德勒"},{"title":"友链","date":"2020-06-25T07:08:13.000Z","updated":"2023-02-20T10:17:42.696Z","comments":false,"path":"friends/index_bk.html","permalink":"https://jingyu.life/friends/index_bk","excerpt":"","text":""},{"title":"tags","date":"2023-02-20T07:28:11.000Z","updated":"2023-02-21T14:35:29.826Z","comments":false,"path":"tags/index.html","permalink":"https://jingyu.life/tags/","excerpt":"false","text":""},{"title":"所有分类","date":"2023-02-21T14:08:17.000Z","updated":"2023-02-21T14:11:10.188Z","comments":false,"path":"blog/categories/index.html","permalink":"https://jingyu.life/blog/categories/","excerpt":"","text":""},{"title":"友链","date":"2023-02-21T14:40:58.000Z","updated":"2023-02-21T14:44:13.738Z","comments":false,"path":"blog/friends/index.html","permalink":"https://jingyu.life/blog/friends/","excerpt":"一些优秀的伙伴，共勉～","text":"一些优秀的伙伴，共勉～"},{"title":"所有标签","date":"2023-02-21T14:14:22.000Z","updated":"2023-02-21T14:14:51.620Z","comments":false,"path":"blog/tags/index.html","permalink":"https://jingyu.life/blog/tags/","excerpt":"","text":""}],"posts":[{"title":"Gvm-Go版本管理工具","slug":"go/gvm-usage","date":"2023-03-13T07:25:28.000Z","updated":"2023-03-13T16:45:09.437Z","comments":false,"path":"2023/03/13/go/gvm-usage/","link":"","permalink":"https://jingyu.life/2023/03/13/go/gvm-usage/","excerpt":"Go语言版本迭代很快，几乎每个月更新一个小版本。对于我这样一个特别喜欢使用最新版本的人来说，就希望能够便捷的管理Go版本，Gvm就是一款这样的工具。","text":"Go语言版本迭代很快，几乎每个月更新一个小版本。对于我这样一个特别喜欢使用最新版本的人来说，就希望能够便捷的管理Go版本，Gvm就是一款这样的工具。 记录安装时，个人用的是Ubuntu22.04系统 安装Gvm1bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 执行命令时，可能会有如下提示 按照提示，安装bison sudo apt install bison 安装完成后，执行 source 命令 最后检查gvm是否安装成功gvm version Gvm相关命令可以使用gvm help查看相关帮助 常用命令1234567891011# 查看可以安装的版本$ gvm listall# 查看本地安装的版本$ gvm list# 安装某个版本 # 看到这里先别急着安装，看到后面具体安装部分再操作$ gvm install [version]# 卸载某个版本 $ gvm uninstall [version]# 使用某个版本$ gvm use [version] [--default] 安装Go版本要安装最新版本，先必须安装go1.4, 因为1.4版本实现了go的自举更新 要构建 x ≥ 5 的 Go 1.x，必须在 $GOROOT_BOOTSTRAP 中已经安装 Go 1.4 12345678910111213141516# 1. 安装1.4版本 使用源码$ gvm install go1.4 -B# 2. 使用1.4版本$ gvm use go1.4# 3. 导入临时环境变量自举起使版本$ export GOROOT_BOOTSTRAP=$GOROOT# 4. 下载go1.17.13$ gvm install go1.17.13# 5. 使用go.17.13$ gvm use go1.17.13# 6. 重新设置环境变量自举起使版本$ export GOROOT_BOOTSTRAP=$GOROOT# 7. 下载最新版本$ gvm install go1.20.2# 8. 使用最新版本，并根据个人爱好，是否成默认$ gvm use go1.20.2 --default 注意 直接下载最新版本会报错 1can&#x27;t load package: package ./cmd/dist: found packages build.go (main) and notgo117.go (building_Go_requires_Go_1_17_13_or_later) 需要我们先安装go1.17.13版本，然后将其作为GOROOT_BOOTSTRAP，参考这里 了解12$ cd ~/.gvm$ tree -L 1 123456789101112131415161718192021222324252627.├── archive github go源码仓库├── AUTHORS├── autogen.sh├── bin├── binscripts├── ChangeLog├── config├── configure.ac├── environments├── examples├── extra├── Gemfile├── git.bak├── gos go的安装目录 也就是GOROOT, 类似于Java JDK， 从archive目录中克隆过来的├── LICENSE├── logs├── Makefile.am├── NEWS├── pkgsets go项目工作空间，保存三方包的依赖├── Rakefile├── README├── README.md├── scripts├── tests├── Vagrantfile└── VERSION","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://jingyu.life/tags/Go/"},{"name":"Gvm","slug":"Gvm","permalink":"https://jingyu.life/tags/Gvm/"}]},{"title":"迭代器和生成器","slug":"node/iterator-generator","date":"2023-03-13T02:22:12.000Z","updated":"2023-03-13T16:04:28.292Z","comments":false,"path":"2023/03/13/node/iterator-generator/","link":"","permalink":"https://jingyu.life/2023/03/13/node/iterator-generator/","excerpt":"在了解for…of遍历的时候，简单的提到了可迭代对象这个词，这里来具体了解一下","text":"在了解for…of遍历的时候，简单的提到了可迭代对象这个词，这里来具体了解一下 前言前面说到可迭代对象是含有Symbol.iterator属性的对象。具体说到可迭代对象，就要涉及到迭代器和生成器。 迭代器迭代器本身是一个对象，这个对象是具有next()方法返回结果对象。这个返回对象是一个&#123;value: any, done: boolean&#125;格式的对象。 一旦创建迭代器对象，这个对象可以通过重复调用next()方法显示地迭代。迭代一个迭代器对象，就成为消耗了这个迭代器，因为它通常只能执行一次，在产生了终值以后，调用next方法会返回一个{done: true, value: undefined}的对象 12345678910111213141516171819function createIterator(items) &#123; let index = 0 return &#123; next()&#123; let result = &#123;value: undefined, done: true&#125; if (index &lt; items.length)&#123; result = &#123;value: items[index], done: false&#125; index += 1 &#125; return result &#125; &#125;&#125;const it = createIterator([1,2,3])console.log(it.next()) // &#123;value: 1, done: false&#125;console.log(it.next()) // &#123;value: 2, done: false&#125;console.log(it.next()) // &#123;value: 3, done: false&#125;console.log(it.next()) // &#123;value: undefined, done: true&#125; 123456789101112131415161718192021function createRangeIterator(start = 0,end = Infinity,step = 1)&#123; let value = start const iterator = &#123; next()&#123; let result = &#123;value: undefined, done: true&#125; if (value &lt;= end)&#123; result = &#123;value: value, done: false &#125; value += step &#125; return result &#125; &#125; return iterator&#125;const rit = createRangeIterator(1, 7, 2)let result = rit.next() while (!result.done)&#123; console.log(result.value) // 1 3 5 7 result = rit.next() // 重复调用， 显示迭代&#125; 每次调用迭代器的next()方法，都会返回下一个对象，直到数据集被用尽 生成器自定义的迭代器，需要我们显示的维护其内部的状态，故需要谨慎创建。生成器函数，可以帮助我们创建一个迭代器对象 生成器函数，使用function* 语法， 返回一种成为generator的迭代器。调用生成器的下一个方法消耗值时，generator函数将执行，直到遇到yield关键字 123456789101112131415161718function* createRangeIterator(start = 0, end = Infinity, step = 1)&#123; for(let i = start; i &lt;= end; i += step)&#123; yield i &#125;&#125;const rit = createRangeIterator(1, 7, 2)let result = rit.next()while(!result.done)&#123; console.log(result.value) // 1 3 5 7 result = rit.next()&#125;// 使用for...of语法遍历const rit1 = createRangeIterator(1, 7, 2)for(const item of rit1)&#123; console.log(item) // 1 3 5 7&#125; 使用生成器函数创建的迭代器，比之前自定义的生成器精简了不少 高级生成器 生成器中next()方法也是可以接受一个参数，用于修改生成器内部的状态。传递给next()方法的参数会被yield接收。但传递给第一next()方法的参数会被忽略 12345678910111213141516171819202122232425262728293031function *createIterator()&#123; const param1 = yield 1 console.log(&#x27;param1&#x27;, param1) // param1 p2 const param2 = yield 2 console.log(&#x27;param2&#x27;, param2) // param2 p3 const param3 = yield 3 console.log(&#x27;param3&#x27;, param3) // param3 p4&#125;const it = createIterator()console.log(&#x27;result1&#x27;, it.next(&#x27;p1&#x27;)) // result1 &#123;value:1 ,done: false&#125;console.log(&#x27;result2&#x27;, it.next(&#x27;p2&#x27;)) // result2 &#123;value:2 ,done: false&#125;console.log(&#x27;result3&#x27;, it.next(&#x27;p3&#x27;)) // result3 &#123;value:3 ,done: false&#125;console.log(&#x27;result4&#x27;, it.next(&#x27;p4&#x27;)) // result4 &#123;value:undefined ,done: true&#125;// 最终输出结果顺序如下/* result1 &#123;value: 1, done: false&#125; param1 p2 result2 &#123;value:2 ,done: false&#125; param2 p3 result3 &#123;value:3 ,done: false&#125; param3 p4 result4 &#123;value:undefined ,done: true&#125;*/// 另外，对于生成器生成的迭代器，我们可以使用for...of语法const it2 = createIterator()for(const item of it2)&#123; console.log(item) // 1 2 3&#125; 分析 ： 关于参数接收问题， 我们可以看见每次调用next(),显示直接返回结果，拿取下一次调用next()方法中的参数作为当前yield 的返回结果 yield返回参数后，后面的代码不会执行了，只有当下次调用next()时，才会执行到下一个yield的位置 结合以上两个特性，我们可以看出它为什么丢弃了第一次的参数 可迭代对象(iterables)为了实现可迭代，一个对象必须实现 @@iterator方法，这意味着这个对象（或其原型链中的任意一个对象）必须具有一个带 Symbol.iterator键（key）的属性。 对于只迭代一次的iterables,通常从@@iterator返回本身， 对于可以迭代多次的，必须每次调用@@iterator方法返回一个新的迭代器 常用内置可迭代对象: String、Array、TypedArray、Map、Set 12345678910111213141516171819202122232425262728293031const myIterable = &#123; *[Symbol.iterator]()&#123; for (let i = 0; i &lt; 3; i++)&#123; yield i &#125; &#125;&#125;for(const item of myIterable)&#123; console.log(item) // 1 2 3&#125;// 和使用原生迭代器的方式对比一下const myIterable1 = &#123; [Symbol.iterator]: () =&gt; &#123; let index = 0 const end = 3 return &#123; next()&#123; let result = &#123;value: undefined, done: true&#125; if (index &lt; end)&#123; result = &#123;value: index, done: false&#125; index += 1 &#125; return result &#125; &#125; &#125;&#125;console.log([...myIterable1]) // [1, 2, 3]","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"开发/前端","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://jingyu.life/tags/Node/"},{"name":"ES","slug":"ES","permalink":"https://jingyu.life/tags/ES/"}]},{"title":"for...in 和 for...of的使用","slug":"node/for-in-of","date":"2023-03-10T07:23:08.000Z","updated":"2023-03-10T17:05:37.388Z","comments":false,"path":"2023/03/10/node/for-in-of/","link":"","permalink":"https://jingyu.life/2023/03/10/node/for-in-of/","excerpt":"在ES中，遍历数据的时候会用到for…in&#x2F;of的语法，比较一下两者的用法","text":"在ES中，遍历数据的时候会用到for…in&#x2F;of的语法，比较一下两者的用法 for…offor…of是ES6的语法，用来遍历可迭代的对象(含有Symbol.iterator属性的对象)。像Array, Map, Set, 字符串等 简单使用1234567891011121314151617181920212223242526const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]for(const item of arr1)&#123; console.log(item) // a b c&#125;const map1 = new Map()map1.set(&#x27;k1&#x27;, &#x27;v1&#x27;)map1.set(&#x27;k2&#x27;, 1)map1.set(&#x27;k3&#x27;, &#123;&#x27;name&#x27;: &#x27;kobe&#x27;&#125;)for(const item of map1)&#123; console.log(item) // [&#x27;k1&#x27;, &#x27;v1&#x27;] [&#x27;k2&#x27;, 1] [&#x27;k3&#x27;, &#123;&quot;name&quot;: &quot;kobe&quot;&#125;] // const [k, v] = item // console.log(k, v)&#125;const set1 = new Set()set1.add(&#x27;hello&#x27;)set1.add(100)set1.add(&#123;&#x27;name&#x27;: &#x27;kobe&#x27;&#125;)const obj = &#123;eat: () =&gt; &#123;console.log(&#x27;eat&#x27;)&#125;&#125;set1.add(obj)for(const item of set1)&#123; console.log(item) // hello 100 &#123;&#x27;name&#x27;:&#x27;kobe&#x27;&#125; &#123;eat: () =&gt; &#123;console.log(&#x27;eat&#x27;)&#125;&#125;&#125; 手动实现forOf1234567891011121314151617const forOf = (obj, cb) =&gt; &#123; let iterable, result console.log(obj, typeof obj[Symbol.iterator]) if(typeof obj[Symbol.iterator] !== &#x27;function&#x27;)&#123; throw new TypeError(&#x27;params is not a iterable&#x27;) &#125; iterable = obj[Symbol.iterator]() result = iterable.next() while(!result.done)&#123; cb &amp;&amp; cb(result.value) result = iterable.next() &#125;&#125;forOf([1,2,3], (item) =&gt; &#123;console.log(item)&#125;) 实现遍历普通对象由于普通对象没有Symbol.iterator属性，故不能使用for…of, 若要使用，则需要先处理 使用Object扩展方法 Object.keys()、Object.values()、Object.entries()123456789101112131415161718192021222324const obj = &#123; name: &#x27;kobe&#x27;, age: 18, friends: [ &#123; name: &#x27;james&#x27; &#125; ]&#125;// 返回普通对象的键名组成的数组for(const item of Object.keys(obj))&#123; console.log(item) // name age friends&#125;// 返回普通对象的键值组成的数组for(const item of Object.values(obj))&#123; console.log(item) // kobe 18 [&#123;name: &#x27;james&#x27;&#125;]&#125;// 返回普通对象的键名键值组成的二维数组for(const item of Object.entries(obj))&#123; console.log(item) // [&#x27;name&#x27;, &#x27;kobe&#x27;] [&#x27;age&#x27;, 18] [&#x27;friends&#x27;, [&#123;&#x27;name&#x27;: &#x27;james&#x27;&#125;]]&#125; 生成器函数重新包装1234567891011121314151617181920const obj = &#123; name: &#x27;kobe&#x27;, age: 18, friends: [ &#123; name: &#x27;james&#x27; &#125; ]&#125;function* entries(obj) &#123; for(let key of Object.keys(obj))&#123; yield [key, obj[key]] &#125;&#125;for(const item of entries(obj))&#123; console.log(item) // [&#x27;name&#x27;, &#x27;kobe&#x27;] [&#x27;age&#x27;, 18] [&#x27;friends&#x27;, [&#123;&#x27;name&#x27;: &#x27;james&#x27;&#125;]]&#125; 在对象上添加Symbol.iterator属性123456789101112131415161718192021222324252627282930const obj = &#123; name: &#x27;kobe&#x27;, age: 18, friends: [ &#123; name: &#x27;james&#x27; &#125; ]&#125;obj[Symbol.iterator] = function()&#123; const keys = Object.keys(this) let i = 0 return &#123; // 这里如果需要使用外卖的作用域this, 需要使用箭头函数 next: () =&gt; &#123; let value = undefined, done = true if (i &lt; keys.length)&#123; value = this[keys[i]] done = false i = i + 1 &#125; return &#123;value, done&#125; &#125; &#125;&#125;for(const item of obj)&#123; console.log(item)&#125; for…infor…in是ES5的语法，用于遍历可枚举的对象，包括原型 12345678910111213141516171819202122232425262728293031const obj = &#123; name: &#x27;kobe&#x27;, age: 18, friends: [ &#123; name: &#x27;james&#x27; &#125; ]&#125;for(const key in obj)&#123; console.log(key, &#x27;-&gt;&#x27;, obj[key]) // name -&gt; kobe age -&gt; 18 friends -&gt; [&#123;&#x27;name&#x27;: &#x27;james&#x27;&#125;&#125;]&#125;const obj2 = [1, 2, 3]for(const key in obj2)&#123; console.log(key, &#x27;-&gt;&#x27;, obj2[key]) // 0 - &gt; 1 1 -&gt; 2 2 -&gt; 3&#125;Array.prototype.a = 123for(const key in obj2)&#123; console.log(key, &#x27;-&gt;&#x27;, obj2[key]) // 0 - &gt; 1 1 -&gt; 2 2 -&gt; 3 a -&gt; 123&#125;// 不获取原型链上的属性for(const key in obj2)&#123; if (obj2.hasOwnProperty(key))&#123; console.log(key, &#x27;-&gt;&#x27;, obj2[key]) // 0 - &gt; 1 1 -&gt; 2 2 -&gt; 3 &#125;&#125; 小结for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值 for in总是得到对象的key或数组、字符串的下标 for of总是得到对象的value或数组、字符串的值 for...of不能遍历普通Object对象","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"开发/前端","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://jingyu.life/tags/Node/"},{"name":"ES","slug":"ES","permalink":"https://jingyu.life/tags/ES/"}]},{"title":"防抖和节流","slug":"node/debounce-throttle","date":"2023-03-09T03:01:29.000Z","updated":"2023-03-10T10:47:10.285Z","comments":false,"path":"2023/03/09/node/debounce-throttle/","link":"","permalink":"https://jingyu.life/2023/03/09/node/debounce-throttle/","excerpt":"防抖和节流，是当频繁触发某个事件时，对其做出相关限制。在在后端开发中，使用防抖和节流，可以减少向服务器请求的频率","text":"防抖和节流，是当频繁触发某个事件时，对其做出相关限制。在在后端开发中，使用防抖和节流，可以减少向服务器请求的频率 概念防抖: 延迟执行。 n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 节流: 固定时间内执行。n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 效果示意图 实现未实现防抖和节流 定义两个页面元素 12&lt;input type=&#x27;text&#x27; class=input /&gt;&lt;h2 class=&#x27;result&#x27;&gt; 监听元素输入事件 12345678910111213141516const inputEl = document.querySelector(&#x27;.input&#x27;)const resultEl = document.querySelector(&#x27;.result&#x27;)async function getRemoteData()&#123; const text = this.value // 模拟网络请求 const result = await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(text) &#125;, 500) &#125;) resultEl.innerHTML = `输入内容为: $&#123;result&#125;`&#125;inputEl.addEventListener(&#x27;input&#x27;, getRemoteData) 防抖使用setTimeout和clearTimeout实现 123456789101112131415// 定义防抖函数function debouce(event, await)&#123; let timer = null return function(...args) &#123; // 每次触发后，判断是否已经有了定时器， 如果有，清除 if (timer) clearTimeout(timer) // 如果没有，定义一个定时器， await事件后执行 timer = setTimeout(() =&gt; &#123; event.apply(this, args) &#125;, await) &#125;&#125; // 重新绑定input事件inputEl.addEventListener(&#x27;input&#x27;, debouce(getRemoteData, 1000)) 节流时间戳的方式12345678910111213function throttle(event, await) &#123; let pre = 0 return function(...args) &#123; // 判断和上一次执行时间的间隔是否大于await if (new Date() - pre &gt; await)&#123; pre = new Date() event.apply(this, args) &#125; &#125;&#125;// 使用这种方式，有一个弊端，就是最后一次事件，可能不会执行(当n和n-1的时间间隔大于await才会执行)inputEl.addEventListener(&#x27;input&#x27;, throttle(getRemoteData, 1000)) 定时器的方式1234567891011121314function throttle(event, await) &#123; let timer = null return function(...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null //执行完成后，需要将变量重置，然后重新生成新的定时器 event.apply(this, args) &#125;, await) &#125; &#125;&#125; // 使用这种方式，就是第一次事件触发后不会立即执行， 不过问题也不大inputEl.addEventListener(&#x27;input&#x27;, throttle(getRemoteData, 1000)) 时间戳和定时器结合1234567891011121314151617function throttle(event, await) &#123; let pre = 0, timer = null return function(...args) &#123; if (new Date() - pre &gt; await) &#123; // 这里判断一下的逻辑是， 上一次(定时器)和现在(时间戳)的方式需要转换，清除上一次的变量,或者说替换上一次的执行 if (timer) &#123; clearTimeout(timer) timer = null &#125; event.apply(this, args) &#125; else &#123; timer = setTimeout(() =&gt; &#123; event.apply(this, args) &#125;, await) &#125; &#125;&#125; 使用三方库lodash使用​ 可以通过npm下载管理， ​ 我这里就直接使用cdn方式 12&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt; _.debounce(func, wait, option) 1inputEl.addEventListener(&#x27;input&#x27;, _.debounce(getRemoteData, 1000)) _.throttle(func, wait, option) 1inputEl.addEventListener(&#x27;input&#x27;, _.throttle(getRemoteData, 1000)) 应用场景防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"开发/前端","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://jingyu.life/tags/Node/"},{"name":"ES","slug":"ES","permalink":"https://jingyu.life/tags/ES/"}]},{"title":"VsCode常用插件介绍","slug":"tools/vscode-plugins","date":"2023-03-07T01:26:13.000Z","updated":"2023-03-10T10:47:10.286Z","comments":false,"path":"2023/03/07/tools/vscode-plugins/","link":"","permalink":"https://jingyu.life/2023/03/07/tools/vscode-plugins/","excerpt":"vscode插件繁多，记录经常使用的插件","text":"vscode插件繁多，记录经常使用的插件 公用 插件 功能 Tabnine 自动补全代码 Live Server 启动一个本地服务器 vscode-icons 文件显示图标 Remote-SSH 编辑远程服务器上的文件 Bookmarks 给代码打上标签，方便阅读快速跳转 Prettier 格式化代码 Editorconfig 统一代码格式规范 前端开发 插件 功能 Volar 代码高亮，语法提示等 Vue VSCode Snippets 便捷语法功能, eg: vbase ESLint 检查ES语法 PHP开发 插件 功能 PHP Intelephense 自动导包，搜索跳转功能 Python开发 插件 功能 Pylance 自动导包，搜索跳转功能等 Go开发 插件 功能 go 自动导包，搜索跳转功能等","categories":[{"name":"工具","slug":"工具","permalink":"https://jingyu.life/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://jingyu.life/tags/VsCode/"}]},{"title":"Promise介绍以及使用","slug":"node/promise-usage","date":"2023-03-06T01:28:51.000Z","updated":"2023-03-10T10:47:10.286Z","comments":false,"path":"2023/03/06/node/promise-usage/","link":"","permalink":"https://jingyu.life/2023/03/06/node/promise-usage/","excerpt":"Promise， “一诺千金”，异步编程的解决方案","text":"Promise， “一诺千金”，异步编程的解决方案 介绍ES6中的原生内置对象，用来更加优雅地书写复杂的异步任务的代码 promise有三个状态, pending(进行中), fulfilled(成功), rejected(失败)。其状态不受外界影响，只要有异步操作的结果，可以决定当前是什么状态，其他任何操作都无法改变。另外，状态一旦发生变化，就不会再变 状态转换如图所示 基本使用123456789101112131415161718192021222324252627const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;123&#x27;)&#125;)p1.then( (res) =&gt; &#123; console.log(res) // 123 &#125;, (err) =&gt; &#123; console.log(err) &#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; // 三种写法一样，都是返回一个rejected promise throw new Error(&#x27;error_test&#x27;) // resolve(new Error(&#x27;error_test&#x27;)) // reject(new Error(&#x27;error_test&#x27;))&#125;)p2.then(res=&gt; &#123; console.log(p2) console.log(res) &#125;).catch(err =&gt; &#123; console.log(p2) // rejected console.log(err) // Error: error_test&#125;) 方法promise.prototype.then()Promise实例具有then方法， 起作用就是为Promise实例添加状态改变时的回调函数。 then方法有两个参数,结构为 then((res) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;), 这两个参数均为可选, 通常我们不会采用这样的方式，而是将成功和失败的回调分别放入到then和catch中 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(123) // reject(234)&#125;)p1.then((res) =&gt; &#123; console.log(res) // 123&#125;, (err) =&gt; &#123; console.log(err)&#125;)p1.then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) then方法返回值问题 如没有设置返回，或者return一个普通的值或者对象，则返回一个fulfilled状态的promise, 若return 一个promise ， 则then方法也返回一个promise,状态和其一致，但不是同一个对象 这样的特性可以实现链式调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. 不显示设置返回值const r1 = p1.then() console.log(r1) // 得到的是一个值为undefined，状态为fulfilld的promise// 2. 设置普通参数/对象const r2 = p1.then((res) =&gt; &#123; return 456 return &#123;name: &#x27;coder&#x27;, age: 18&#125;&#125;)console.log(r2) // 值为then中return的参数，状态为fulfilled的参数r2.then(res =&gt; &#123; console.log(res) // 456&#125;)// 3. promise对象// 3.1 pendingconst p_pending = new Promise((resolve, reject) =&gt; &#123;&#125;)const r3_1 = p1.then((res) =&gt; &#123; return p_pending &#125;)console.log(r3_1, r3_1 == p_pending) // 状态为pending的promise// 3.2 fulfilled const p_resolved = Promise.resolve(&#x27;promise resolve&#x27;)const r3_2 = p1.then((res) =&gt; &#123; return p_resolved&#125;)console.log(r3_2, r3_2 == p_resolved) // 状态为fulfilled，值为promise resolve 的promise， 和传入的对象不是同一个r3_2.then(res =&gt; &#123; console.log(res) // promise resolve&#125;).catch(err =&gt; &#123; console.log(err) &#125;)// 3.3 rejectedconst p_rejected = Promise.reject(&#x27;promise rejected&#x27;)const r3_3 = p1.then(res =&gt; &#123; return p_rejected&#125;)console.log(r3_3, r3_3 == p_rejected) // 状态为rejected, 返回值为promise rejeced的promise, 和传入参数不是同一个r3_3.then(res =&gt; &#123; console.log(res) &#125;).catch(err =&gt; &#123; console.log(err) // promise rejected&#125;) promise.prototype.catch()catch((err) =&gt; &#123;&#125;) 是then(null, (err) =&gt; &#123;&#125;)的别名， 当状态由pending变为rejected时，发生的回调 1234567const p1 = new Promise((resolve, reject) =&gt; &#123; reject(123)&#125;)p1.catch((err) =&gt; &#123; console.log(err)&#125;) catch方法返回值问题 由于其本质是then,所以返回值上面说的then方法返回值是一样的 这里就不再赘述了。 注意一点， 一定写捕获的方法体 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const p1 = new Promise((resolve, reject) =&gt; &#123; reject(123)&#125;)// 1. 不显示设置返回值const r1 = p1.catch((err) =&gt; &#123; console.log(err) &#125;) // 若写成 const r1 = p1.catch() , 则返回一个rejected的promiseconsole.log(r1) // 返回一个fulfilled 状态的promise, 值为undefined// 2. 设置普通参数/对象const r2 = p1.catch((err) =&gt; &#123; return 456 return &#123;name: &#x27;coder&#x27;, age: 18&#125;&#125;)console.log(r2) // 值为catch中return的参数，状态为fulfilled的参数r2.then(res =&gt; &#123; console.log(res) // 456&#125;)// 3. promise对象// 3.1 pendingconst p_pending = new Promise((resolve, reject) =&gt; &#123;&#125;)const r3_1 = p1.catch((err) =&gt; &#123; return p_pending &#125;)console.log(r3_1, r3_1 == p_pending) // 状态为pending的promise// 3.2 fulfilled const p_resolved = Promise.resolve(&#x27;promise resolve&#x27;)const r3_2 = p1.catch((err) =&gt; &#123; return p_resolved&#125;)console.log(r3_2, r3_2 == p_resolved) // 状态为fulfilled，值为promise resolve 的promise， 和传入的对象不是同一个r3_2.then(res =&gt; &#123; console.log(res) // promise resolve&#125;).catch(err =&gt; &#123; console.log(err) &#125;)// 3.3 rejectedconst p_rejected = Promise.reject(&#x27;promise rejected&#x27;)const r3_3 = p1.catch(err =&gt; &#123; return p_rejected&#125;)console.log(r3_3, r3_3 == p_rejected) // 状态为rejected, 返回值为promise rejeced的promise, 和传入参数不是同一个r3_3.then(res =&gt; &#123; console.log(res) &#125;).catch(err =&gt; &#123; console.log(err) // promise rejected&#125;) promise.prototype.finally()不管promise最后状态是什么，都会执行的操作， ES2018引入的 finally() 接受一个回调函数， 回调函数中没有参数 123456789101112promise.finally(() =&gt; &#123; // 语句&#125;)// 等价于promise.then((res) =&gt; &#123; // 语句 return res&#125;, (err) =&gt; &#123; // 语句 throw err&#125;) 12345678910111213141516171819202122const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(123)&#125;)p1.then((res) =&gt; &#123; console.log(&#x27;then&#x27;) console.log(res)&#125;).finally(() =&gt; &#123; console.log(&#x27;finally&#x27;)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; reject(456)&#125;)p2.catch((err) =&gt; &#123; console.log(&#x27;catch&#x27;) console.log(err)&#125;).finally(() =&gt; &#123; console.log(&#x27;finally&#x27;)&#125;) finally返回值问题 finally没有特别的返回值， 或者说，返回的是调用finally方法的对象的拷贝对象 12345678910111213141516171819202122232425262728293031323334353637const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(123)&#125;)const r1 = p1.then((res) =&gt; &#123; console.log(&#x27;then&#x27;) console.log(res)&#125;).finally(() =&gt; &#123; console.log(&#x27;finally&#x27;) return Promise.resolve(&#x27;promise resolve&#x27;)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; reject(456)&#125;)const r2 = p2.catch((err) =&gt; &#123; console.log(&#x27;catch&#x27;) console.log(err)&#125;).finally(() =&gt; &#123; console.log(&#x27;finally&#x27;) return Promise.resolve(&#x27;promise reject&#x27;)&#125;)const r3 = p1.finally(() =&gt; &#123; return Promise.resolve(&#x27;promise resolve&#x27;)&#125;)const r4 = p2.finally(() =&gt; &#123; return Promise.resolve(&#x27;promise reject&#x27;)&#125;)// 解释 由于 在调用finally之前，分别调用了 then/catch, 返回的promise就是如下状态，再次调用finally,不会返回我们想要的返回值console.log(r1, r2) // [fulfilled, undefined] [fulfilled, undefined]// 这里也就能理解为什么会返回p1, p2 一样的状态了console.log(r3, r4) // [fulfilled, 123] [rejected, 456] promise.resolve()将一个对象包装成一个Promise对象, 关于返回的promise的状态，取决于参数的类型 若使用普通参数，或者不使用参数， 则返回一个fulfilled状态的promise 若参数是一个promise对象，则原封不动的返回这个对象，它是什么状态，返回的就是什么状态 若参数是一个thenable对象， 这回状态一个Promise对象，并立即调用then方法，方法返回的promise对象就是最后返回的promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 1. 不使用参数const p1 = Promise.resolve()p1.then(res =&gt; &#123; console.log(p1) // promise fulfilled console.log(res) // undefined&#125;)// 2. 使用普通参数const p2 = Promise.resolve(&#123;name: &#x27;coder&#x27;, age: 18&#125;)p2.then((res) =&gt; &#123; console.log(p2) // fulfiled状态的promise console.log(res) // &#123;name: &#x27;coder&#x27;, age: 18&#125;&#125;)// 3. thenable对象(含有then方法的对象)const p3_1 = Promise.resolve(&#123;then: (resolve, reject) =&gt; &#123; resolve(&#x27;thenable resolve&#x27;)&#125;&#125;)p3_1.then((res) =&gt; &#123; console.log(p3_1) //fulfiled状态的promise console.log(res) // thenable resolve&#125;)const p3_2 = Promise.resolve(&#123;then: (resolve, reject) =&gt; &#123; reject(&#x27;thenable reject&#x27;)&#125;&#125;)p3_2.catch((err) =&gt; &#123; console.log(p3_2) // rejected状态的promise console.log(err) // thenable reject&#125;)// 4. promise对象// 4.1 传入pending状态const p_pending = new Promise((resolve, reject) =&gt; &#123; // 没有调用 resolve/ reject， 故状态为pending&#125;)const p4_1 = Promise.resolve(p_pending) // 说明如参数是promise对象， 则会原封不动的返回这个参数console.log(p_pending === p4_1) // truep4_1.then(res=&gt; &#123; console.log(res) // 没有输出&#125;).catch(err =&gt; &#123; console.log(err) // 没有输出&#125;)// 4.2 传入fulfilled状态const p_resolved = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;promise resolve&#x27;)&#125;)// const p_resolve = Promise.resolve(&quot;promise resolve&quot;)const p4_2 = Promise.resolve(p_resolved)console.log(p_resolved === p4_2) // truep4_2.then(res=&gt; &#123; console.log(res) // promise resolve&#125;).catch(err =&gt; &#123; console.log(err) // 没有输出&#125;)// 4.3 传入rejected 状态const p_rejected = new Promise((resolve, reject) =&gt; &#123; reject(&#x27;promise reject&#x27;)&#125;)const p4_3 = Promise.resolve(p_rejected)console.log(p_rejected == p4_3) // truep4_3.then(res=&gt; &#123; console.log(res) // 没有输出&#125;).catch(err =&gt; &#123; console.log(err) // promise reject&#125;) Promise.reject()创建一个rejected状态的promise, 其状态为rejected,与传入的参数无关 对于传入的参数， Promise.reject 会将其作为 失败的原因返回，在catch((err) =&gt; &#123;&#125;) 中捕获 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 1. 没有参数const p1 = Promise.reject()p1.then((res) =&gt; &#123; console.log(res) // 没有数据&#125;).catch((err) =&gt; &#123; console.log(err) // undefined console.log(p1) // rejected&#125;)// 2. 普通参数或对象const p2_1 = Promise.reject(&#123;name: &#x27;coder&#x27;, age: 18&#125;)p2_1.then((res) =&gt; &#123; console.log(res) // 没有数据&#125;).catch((err) =&gt; &#123; console.log(err) // &#123;name: &#x27;coder&#x27;, age: 18&#125; console.log(p2_1) // rejected&#125;)const p2_2 = Promise.reject(new Error(&#x27;error_test&#x27;)) p2_2.then((res) =&gt; &#123; console.log(res) // 没有数据&#125;).catch((err) =&gt; &#123; console.log(err) // Error: error_test console.log(p2_2) // rejected&#125;)// 3. Promise对象// 3.1 pending const p_pending = new Promise((resolve, reject) =&gt; &#123;&#125;)const p3_1 = Promise.reject(p_pending)console.log(p3_1 == p_pending) // falsep3_1.then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err, p_pending == err) // promise , true console.log(p3_1)&#125;)// 3.2 fulfilled const p_resolved = Promise.resolve(&#x27;promise resolve&#x27;)const p3_2 = Promise.reject(p_resolved)p3_2.then(res =&gt; &#123; console.log(res) console.log(p3_2)&#125;).catch(err =&gt; &#123; console.log(err, p_resolved == err) // promise , true err.then((res) =&gt; &#123; console.log(res) // promise resolve &#125;)&#125;)// 3.3 rejectedconst p_rejected = Promise.reject(&#x27;promise reject&#x27;)const p3_3 = Promise.reject(p_rejected)p3_3.then(res =&gt; &#123; console.log(res) console.log(p3_3)&#125;).catch(err =&gt; &#123; console.log(err, p_rejected == err) // promise , true err.catch((i_err) =&gt; &#123; console.log(i_err) // promise reject &#125;)&#125;) Promise.all()Promise.all()将多个Promise实例包装成一个Promise, 其接受一个promise实例的数组，返回的Promise实例，它的状态改变规则如下: 只有当数组中的所有实例状态都变为fulfilled,其状态才会改为fulfilled状态,并将所有promise实例的结果作为一个数组返回 当其中存在promise返回值为rejected, 其状态就为rejected, 第一个被rejected的实例的返回值，会被传给Promise实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p1 resolve&#x27;) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p2 resolve&#x27;) &#125;, 1200)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p3 resolve&#x27;) &#125;, 1500)&#125;)const p4 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p4 reject&#x27;) &#125;, 1300)&#125;)const p5 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p5 reject&#x27;) &#125;, 1000)&#125;)const p_all1 = Promise.all([p1, p2, p3]) p_all1.then((res) =&gt; &#123; console.log(res) // [&#x27;promise p1 resolve&#x27;, &#x27;promise p2 resolve&#x27;, &#x27;promise p3 resolve&#x27;] console.log(p_all1) // &#123; fullfiled, Array &#125;&#125;).catch(err =&gt; &#123; console.log(err) console.log(p_all1)&#125;) const p_all2 = Promise.all([p1, p3, p4, p5])p_all2.then((res) =&gt; &#123; console.log(res) console.log(p_all2) &#125;).catch(err =&gt; &#123; console.log(err) // promise p5 reject console.log(p_all2) // &#123;rejected, &#x27;promise p5 reject&#x27;&#125;&#125;)const p6 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p6 reject&#x27;) &#125;, 800)&#125;).catch(err =&gt; &#123; console.log(err)&#125;)const p_all3 = Promise.all([p1, p3, p6])p_all3.then((res) =&gt; &#123; console.log(res) // [&#x27;promise p1 resolve&#x27;, &#x27;promise p3 resolve&#x27;, undefined] console.log(p_all3) // &#123; fullfiled, Array &#125;&#125;).catch(err =&gt; &#123; console.log(err) console.log(p_all3)&#125;) Promise.race()这个方法也是将多个实例，包装成一个Promise实例. 和Promise.all的区别在于，Promise.race更关心哪一个实例先执行完成(无论状态) 多一个实例中，只要有一个实例先完成，则最后返回的实例，就是这个实例的状态和值. race, 竞争，只关注第一个状态改变 123456789101112131415161718192021222324252627282930313233343536373839const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p1 resolve&#x27;) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p2 resolve&#x27;) &#125;, 1200)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p3 reject&#x27;) &#125;, 1100)&#125;)const p4 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p4 reject&#x27;) &#125;, 800)&#125;)const p_race1 = Promise.race([p1, p2, p3])p_race1.then((res) =&gt; &#123; console.log(res) // promise p1 resolve console.log(p_race1, p_race1 == p1) // false, 说明返回的是一个新的实例&#125;).catch(err =&gt; &#123; console.log(err)&#125;)const p_race2 = Promise.race([p1, p2, p4])p_race2.then((res) =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err) // promise p3 reject console.log(p_race2, p_race2 == p4) // false&#125;) Promise.any()这个也是将多个实例包装成一个Promise实例，和Promise.all 的区别在于，这个只需要其中一个实例是fulfilled，最后返回的实例就是fulfilled, 若所有实例是rejected, 则最后返回的就是一个rejected的promise, 参数是一个 AggregateError 实例，它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误 1234567891011121314151617181920212223242526272829303132333435363738const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p1 resolve&#x27;) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p2 resolve&#x27;) &#125;, 1200)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p3 reject&#x27;) &#125;, 1100)&#125;)const p4 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p4 reject&#x27;) &#125;, 800)&#125;)const p_any1 = Promise.any([p1, p3])p_any1.then(res =&gt; &#123; console.log(res) // promise p1 resolve&#125;).catch(errs =&gt; &#123; console.log(errs)&#125;)const p_any2 = Promise.any([p3, p4])p_any2.then(res =&gt; &#123; console.log(res)&#125;).catch(results =&gt; &#123; console.log(results, results instanceof AggregateError) // AggregateError: All promises were rejected console.log(results.errors) // [&#x27;promise p3 reject&#x27;, &#x27;promise p4 reject&#x27;]&#125;) Promise.allSettled()将一组实例包装成一个promise实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。返回的promise是fulfilled状态，参数为所有实例的状态和值构成的对象的是一个数组 12345678910111213141516171819202122232425262728const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;promise p1 resolve&#x27;) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p2 rejected&#x27;) &#125;, 1000)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;promise p3 rejected&#x27;) &#125;, 1000)&#125;)const p_allSettled1 = Promise.allSettled([p1, p2])const p_allSettled2 = Promise.allSettled([p2, p3])p_allSettled1.then((res) =&gt; &#123; console.log(res) // [ &#123;status: &#x27;fulfilled&#x27;, value: &#x27;promise p1 resolve&#x27;&#125;, &#123;status: &#x27;rejected&#x27;, reason: &#x27;promise p2 rejected&#x27;&#125;]&#125;)p_allSettled2.then((res) =&gt; &#123; console.log(res) // [ &#123;status: &#x27;rejected&#x27;, reason: &#x27;promise p2 rejected&#x27;&#125;, &#123;status: &#x27;rejected&#x27;, reason: &#x27;promise p3 rejected&#x27;&#125; ]&#125;)","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"开发/前端","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://jingyu.life/tags/Node/"},{"name":"ES","slug":"ES","permalink":"https://jingyu.life/tags/ES/"},{"name":"Promise","slug":"Promise","permalink":"https://jingyu.life/tags/Promise/"}]},{"title":"hexo搭建个人博客","slug":"hexo-theme-use","date":"2023-02-21T04:04:41.000Z","updated":"2023-03-13T16:04:28.291Z","comments":false,"path":"2023/02/21/hexo-theme-use/","link":"","permalink":"https://jingyu.life/2023/02/21/hexo-theme-use/","excerpt":"本文记录使用Hexo快速搭建个人博客","text":"本文记录使用Hexo快速搭建个人博客 环境node个人习惯使用nvm管理node版本，参考 node包安装1$ npm install -g yarn hexo-cli 博客项目初始化1$ hexo init blog 运行1$ hexo s 截图 这样，一个简单的博客就搭建好了。然而，这还不够，我们还可以设置一个主题 设置主题我们可以从hexo主题 上选择一个自己喜欢的主题进行下载，我选择的是redefine。 要修改主题的配置，只需要创建_config.[theme].yml文件，对主题中的配置进行覆盖 下载1$ yarn add hexo-theme-redefine 创建_config.redefine.yml填充下面的内容 1theme: redefine 运行1$ hexo s --config _config.yml,_config.redefine.yml 这样，主题也就切换成功了 个人主题配置redefine主题的修改，可以参考官方文档 主题中需要的node包1$ yarn add hexo-theme-redefine hexo-wordcount hexo-generator-searchdb _config.redefine.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371# ---------------------------------------------------------------------------------------# 1. Prepare install# yarn add hexo-theme-redefine hexo-wordcount hexo-generator-searchdb# 2. 删除原先生成的categories tags, 重新生成# rm -rf source/categories source/tags# hexo new page categories# hexo new page tags# ---------------------------------------------------------------------------------------theme: redefinetheme_config: # --------------------------------------------------------------------------------------- # Your basic info # --------------------------------------------------------------------------------------- base_info: title: &quot;Yaurora&#x27;s Blog&quot; # Site title author: Yaurora # Author name url: https://jingyu.life # Site url # Logo image (You can use local image, image external link or don’t fill) logo_img: # logo image on the left of the navigation bar # --------------------------------------------------------------------------------------- # Theme style settings # --------------------------------------------------------------------------------------- style: # Theme primary color primary_color: &#x27;#005080&#x27; # Avatar (You can use local image or image external link) avatar: &#x27;https://cdn.jsdelivr.net/gh/jingyucute/cdn-assets/avatar/young.jpg&#x27; # avatar of the author # Favicon (You can use local image or image external link) favicon: &#x27;https://cdn.jsdelivr.net/gh/jingyucute/cdn-assets/favicon/favicon.ico&#x27; # favicon of the site # Article image align position article_img_align: center # value: left | center # Right side width right_side_width: 210px #sidebar width, for toc # Content area max width content_max_width: 1000px #content max width, for article #navigation bar background color (from left to right) nav_color: left: &#x27;#f78736&#x27; #left side right: &#x27;#367df7&#x27; #right side transparency: 35 #percent (10-99) # Mouse hover hover: shadow: true # shadow effect when the mouse hover scale: false # scale effect when the mouse hover # First screen first_screen: enable: true background_image: light: https://evan.beee.top/img/wallhaven-wqery6-light.webp # background image of the first screen, use relative path or external link (if your website is in subdirectory, use external link) dark: https://evan.beee.top/img/wallhaven-wqery6-dark.webp # background image of the first screen, use relative path or external link (if your website is in subdirectory, use external link) title_color: light: &#x27;#fff&#x27; # first screen title color (light mode) dark: &#x27;#d1d1b6&#x27; # first screen title color (dark mode) font_sizes: title: 2.8rem # first screen title font size subtitle: 1.5rem # first screen subtitle font size line_height: 1.2 # first screen title line height title: &#x27;悟&#x27; # the title in the middle of the first screen. HTML supported (e.g. svg html code of your logo) subtitle: enable: true list: [ &#x27;A % B = A - (A / B) * B&#x27;, &#x27;目之所及,皆是回忆; 心之所想,皆是过往; 眼之所看,皆是遗憾.&#x27; ] custom_font: # custom font for the first screen enable: false font_family: # the font family name of the url below font_url: # The url to the font file # Scroll style settings scroll: progress_bar: # reading progress bar enable: true percent: # reading progress percent enable: false # --------------------------------------------------------------------------------------- # Social contact link # --------------------------------------------------------------------------------------- social_contact: # social contact icons in the first screen, you can add more by using fontawesome icon names enable: true links: github: https://github.com/jingyucute # your GitHub URL instagram: # your Instagram URL zhihu: # your ZhiHu URL twitter: # your twitter URL email: jingyucute@gmail.com # your email # ...... # you can add more # --------------------------------------------------------------------------------------- # Navigation menu # --------------------------------------------------------------------------------------- menu: #you can customize, i18n files are in the theme&#x27;s languages folder. fa-regular recommended Home: path: / icon: fa-regular fa-house # can be empty 文章: icon: fa-regular fa-archive submenus: Archives: /archives 分类: /categories 标签: /tags # Status: # path: https://status.evanluo.top/ # icon: fa-regular fa-chart-bar Links: path: /friends icon: fa-regular fa-link About: icon: fa-regular fa-user submenus: Me: /about Github: https://github.com/jingyucute 书籍: /books # Links: # icon: fa-regular fa-link # submenus: # Link1: /link1 # Link2: /link2 # Link3: /link3 # ...... # you can add more # --------------------------------------------------------------------------------------- # Home page article block display settings # --------------------------------------------------------------------------------------- home_article: date_format: auto # date format in home page article block, value: auto | relative | YYYY-MM-DD | YYYY.MM.DD HH:mm:ss | DD/MM/YYYY | and etc. Support moment js format, see: https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format/ category: enable: false # show category in home page article block limit: 3 # max number of categories shown in home page article block tag: enable: true # show tags in home page article block limit: 3 # max number of tags shown in home page article block # --------------------------------------------------------------------------------------- # Post page Settings # --------------------------------------------------------------------------------------- post: # Post word count # Dependencies: hexo-wordcount (npm install hexo-wordcount) # See: https://github.com/willin/hexo-wordcount word_count: enable: true wordcount: true # word count, one article min2read: true # time to read, one article # Author label author_label: enable: false auto: false # if true, show Lv1, Lv2, Lv3... , If false, show custom label # label array item can be one or more custom_label_list: [&#x27;lol&#x27;] # --------------------------------------------------------------------------------------- # Code copy # --------------------------------------------------------------------------------------- code_block: copy: true # enable code copy button style: mac # mac | simple custom_font: # custom font family, default: Ubuntu Mono enable: false font_family: # font family name font_url: # font url # --------------------------------------------------------------------------------------- # Table of Contents in the Sidebar # --------------------------------------------------------------------------------------- toc: enable: true # Automatically add list number to toc. number: false # If true, all level of TOC in a post will be displayed, rather than the activated part of it. expand_all: true # If true, open TOC every time when you enter the article page init_open: true # --------------------------------------------------------------------------------------- # Post copyright info # --------------------------------------------------------------------------------------- copyright_info: enable: true # --------------------------------------------------------------------------------------- # Website count # --------------------------------------------------------------------------------------- website_count: # busuanzi # See: http://ibruce.info/2015/04/04/busuanzi/ busuanzi_count: enable: false site_uv: false site_pv: false page_pv: true # --------------------------------------------------------------------------------------- # Local Search # Dependencies: hexo-generator-searchdb # See: https://github.com/theme-next/hexo-generator-searchdb # --------------------------------------------------------------------------------------- ## 配合安装 hexo-generator-searchdb local_search: enable: true # 是否在页面加载时预加载搜索数据 preload: true # Preload the search data when the page loads ## 需要设置 local_search.enable = true search: path: search.json field: post content: true format: striptags # --------------------------------------------------------------------------------------- # Comment plugin # --------------------------------------------------------------------------------------- comment: enable: false use: waline # values: waline | gitalk | twikoo # Waline # See: https://waline.js.org/guide/get-started.html waline: serverUrl: # Waline server url(vercel) example: https://example.example.com lang: zh-CN # Waline language, default: zh-CN. See: https://waline.js.org/guide/client/i18n.html # Gitalk # See: https://github.com/gitalk/gitalk gitalk: github_id: # GitHub repo owner repository: # Repository name to store issues client_id: # GitHub Application Client ID client_secret: # GitHub Application Client Secret # Twikoo # See: https://github.com/imaegoo/twikoo twikoo: visitor: true version: 1.6.10 # Twikoo version, do not modify if you dont know what it is env_id: # Vercel or Tencent Cloud Function environment ID region: # environment region. If select Guangzhou, fill in &quot;ap-guangzhou&quot;. (optional) # --------------------------------------------------------------------------------------- # Friend Links page # --------------------------------------------------------------------------------------- friend_links: columns: 3 # number of columns. 2 or 3 # --------------------------------------------------------------------------------------- # RSS # Dependencies: hexo-generator-feed # See: https://github.com/hexojs/hexo-generator-feed # --------------------------------------------------------------------------------------- rss: enable: true feed: type: atom path: atom.xml limit: 20 # --------------------------------------------------------------------------------------- # Lazyload image # --------------------------------------------------------------------------------------- lazyload: enable: true # --------------------------------------------------------------------------------------- # CDN # --------------------------------------------------------------------------------------- cdn: enable: true use: jsdelivr # values: jsdelivr | unpkg | aliyun # aliyun cdn is funded by myself, so if you want to make it work longer, please donate to me. # For donation, please see https://github.com/EvanNotFound/hexo-theme-redefine/blob/dev/DONATION.md # Thank you for your support. # --------------------------------------------------------------------------------------- # PJAX # --------------------------------------------------------------------------------------- pjax: enable: true # --------------------------------------------------------------------------------------- # Article recommendation (transplant from Volantis) # --------------------------------------------------------------------------------------- recommended_article: # 文章推荐，需要 npm install nodejieba enable: false title: 推荐阅读 icon: fa-solid fa-bookmark max_count: 3 placeholder_img: https://evan.beee.top/img/wallhaven-wqery6-light.webp # 不展示文章推荐： # front-matter 使用 skip_recommended_article: true 关闭 # 不在以下文件夹文章中展示文章推荐 根目录是source/ skip_dirs: - wiki/ # --------------------------------------------------------------------------------------- # Fontawesome # --------------------------------------------------------------------------------------- fontawesome: # select fontawesome versions you want to use, in order to reduce the loading time, select as few as possible thin: false # use fontawesome thin version or not light: false # use fontawesome light version or not duotone: false # use fontawesome duotone version or not sharp_solid: false # use fontawesome sharp-solid version or not # --------------------------------------------------------------------------------------- # Footer settings # --------------------------------------------------------------------------------------- footer: runtime: true # show website running time or not start_time: 2020/05/01 00:00:00 # the starting time of your website, format: yyyy/mm/dd hh:mm:ss customize: # customize footer message, can be html code icp: # ICP record number of your website, Can be null enable: false number: # ICP record number url: # ICP record url # --------------------------------------------------------------------------------------- # Custom html code # --------------------------------------------------------------------------------------- inject: enable: true head: # inject code into &lt;head&gt; tag - - footer: # inject code into &lt;footer&gt; tag - - # --------------------------------------------------------------------------------------- # Theme plugins # --------------------------------------------------------------------------------------- plugins: aplayer: # APlayer (fixed version) enable: false audio: - name: # audio name artist: # audio artist url: # audio url cover: # audio cover url - name: artist: url: cover: mermaid: # Mermaid JS enable: false # enable mermaid or not version: &#x27;9.3.0&#x27; # default v9.3.0 # --------------------------------------------------------------------------------------- # Redefine Theme version (Please dont modify it) # Please go to github to update the latest version frequently # Github: https://github.com/EvanNotFound/hexo-theme-redefine # --------------------------------------------------------------------------------------- # version: 1.2.1 #DELETE THIS LINE IN YOUR _config.redefine.yml 多说一点自己很久没有更新博客了，已经忘了之前是怎样更新主题配置文件的具体内容了之前还是使用克隆的方式，将主题下载下来，然后更新其配置文件，所以不留存记录，容易忘记。hexo5之后可以通过npm来管理，使得配置主题特别灵活，可以随时切换主题个人是特别青睐hexo-theme-volantis 这个主题的，改天将这个主题配置一下 volantis主题配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159### 源文件中的配置，不适合全部拷贝### 使用局部覆盖的方式theme: &#x27;volantis&#x27;favicon: https:///cdn.jsdelivr.net/gh/jingyucute/cdn-assets/favicon/favicon.ico# 在页面上加入一些元素或脚本，可以在这写，也可以抽出来.# yaml 文件若能支持引用其他文件该多好import: head_begin: - &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; head_end: - &lt;meta name=&quot;hello&quot; content=&quot;world&quot;&gt; body_begin: - &lt;script&gt;console.log(&quot;Welcome to Yaurora&#x27;s Blog&quot;)&lt;/script&gt; body_end: - &lt;script&gt;&lt;/script&gt;# 覆盖主题配置文件中的内容theme_config: cover: height_scheme: half # full, half scheme: dock # search (搜索), dock (坞), featured (精选), focus (焦点) # 设置在哪些页面使用封面 默认就主页，若想在其他页面显示，对应改为true, 或者在front-matter中使用 cover:true display: home: true archive: false others: false title: &#x27;悟&#x27; subtitle: &#x27;目之所及,皆是回忆; 心之所想,皆是过往; 眼之所看,皆是遗憾. &lt;br /&gt; &lt;span style=&quot;display:block;text-align:center;&quot;&gt;A % B = A - (A / B) * B&lt;/span&gt;&#x27; features: navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: Yaurora&#x27;Blog menu: - name: 首页 icon: fa-solid fa-house url: / - name: 文章 icon: fa-solid fa-rss rows: - name: 归档 icon: fa-solid fa-archive url: /archives/ - name: 分类 icon: fa-solid fa-folder-open url: /categories - name: 标签 icon: fa-solid fa-tags url: /tags - name: 友链 icon: fa-solid fa-link url: /friends - name: 关于 icon: fa-solid fa-info-circle rows: - name: Me icon: fa-solid fa-user url: /about - name: Github icon: fa-solid fa-github url: https://github.com/jingyucute - name: Book icon: fa-solid fa-book-open url: /books - name: hr # - name: 背景音乐 # icon: fa-solid fa-compact-disc search: &#x27;关键字检索&#x27; # placeholder custom_css: max_width: 1080px font_smoothing: true cursor: enable: false text: volantis-static/media/cursor/text.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/text.png pointer: volantis-static/media/cursor/pointer.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/pointer.png default: volantis-static/media/cursor/left_ptr.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/left_ptr.png not-allowed: volantis-static/media/cursor/circle.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/circle.png zoom-out: volantis-static/media/cursor/zoom-out.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/zoom-out.png zoom-in: volantis-static/media/cursor/zoom-in.png # https://gcore.jsdelivr.net/gh/inkss/common@1/cursor/zoom-in.png grab: volantis-static/media/cursor/openhand.png # https # 导航栏样式 navbar: height: 64px width: auto # auto, max effect: [shadow, blur] # 滚动条样式 scrollbar: size: 4px border: 2px color: &#x27;#2196f3&#x27; hover: &#x27;#ff5722&#x27; body: effect: [shadow] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true text_align: # left, right, justify, center h1: left h2: left h3: left h4: left h5: left h6: left p: justify gap: h2: 48px # Spacing above H2 (only px unit) h3: 24px # Spacing above H3 (only px unit) h4: 16px # Spacing above H4 (only px unit) p: 1em # Paragraph spacing between paragraphs line_height: 1.6 # normal, 1.5, 1.75, 2 ... site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [aplayer, social, license, info, copyright] social: - icon: fas fa-rss url: atom.xml - icon: fas fa-envelope url: mailto:jingyucute@gmail.com - icon: fab fa-github url: https://github.com/jingyucute - icon: fas fa-headphones-alt url: https://music.163.com/#/user/home?id=360214433 copyright: &#x27;[Copyright © 2020-2023 Yaurora](/)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; sidebar: widget_library: blogger: shape: circle # circle, rectangle avatar: https://cdn.jsdelivr.net/gh/jingyucute/cdn-assets/avatar/young.jpg social: true plugins: # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS aplayer: enable: true # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 5090178889 # song id / playlist id / album id / search keyword # Optional fixed: false # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: false # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.3 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true autoHide: true # hide automaticaly","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://jingyu.life/tags/Hexo/"}]},{"title":"Redis 基础","slug":"db/redis/basic-usage","date":"2020-10-01T09:57:39.000Z","updated":"2023-03-13T16:04:28.290Z","comments":false,"path":"2020/10/01/db/redis/basic-usage/","link":"","permalink":"https://jingyu.life/2020/10/01/db/redis/basic-usage/","excerpt":"简单记录redis的一些基础用法","text":"简单记录redis的一些基础用法 安装1234567# ubuntu$ sudo apt install redis-server# 编译安装$ wget http://download.redis.io/releases/redis-6.0.8.tar.gz$ tar xzf redis-6.0.8.tar.gz$ cd redis-6.0.8$ make Redis 数据类型 string(字符串)Redis的字符串是动态字符串，可以修改的，内部结构的实现类似于Java的ArrayList，采用预分配的方式。 当字符串的藏毒小于1MB时， 扩容都是加倍现有的空间。当超过1MB时， 扩容时只会多扩容1MB的空间。 字符串最大长度为512MB 1234127.0.0.1:6379&gt; set name &quot;jingyu.life&quot;OK127.0.0.1:6379&gt; get name&quot;jingyu.life&quot; list(列表)Redis的列表相当于Java中的LinkedList，是一个链表。插入和删除都非常快， 但是索引定位很慢。Redis列表结构常用来做异步队列。 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿) 12345678910111213141516# 队列 右进左出127.0.0.1:6379&gt; rpush books java python php shell(integer) 4127.0.0.1:6379&gt; llen books(integer) 4127.0.0.1:6379&gt; lpop books&quot;java&quot;127.0.0.1:6379&gt; lrange books 0 -11) &quot;python&quot;2) &quot;php&quot;3) &quot;shell&quot;# 栈 右进右出127.0.0.1:6379&gt; rpush books java python php shell(integer) 4127.0.0.1:6379&gt; rpop books&quot;shell&quot; hash(字典)Redis的字典相当于Java中的HashMap, 是一个无序键值对集，hash特别适合用于存储对象。 每个 hash 可以存储232 - 1键值对。 123456789101112131415127.0.0.1:6379&gt; hset books java &quot;think in java&quot;(integer) 1127.0.0.1:6379&gt; hset books python &quot;python cookbook&quot;(integer) 1127.0.0.1:6379&gt; hgetall books1) &quot;java&quot;2) &quot;think in java&quot;3) &quot;python&quot;4) &quot;python cookbook&quot;# key value 交替出现127.0.0.1:6379&gt; hlen books(integer) 2127.0.0.1:6379&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot;OK# 批量set set(集合)Redis的集合相当于Java中的HashSet, 无序键值对。内部实现相当于一个特殊的字典， 所有的value都是一个值NULL。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为232 - 1 12345678910111213141516171819127.0.0.1:6379&gt; sadd books python(integer) 1127.0.0.1:6379&gt; sadd books python(integer) 0# 重复添加127.0.0.1:6379&gt; sadd books java php(integer) 2127.0.0.1:6379&gt; smembers books1) &quot;php&quot;2) &quot;java&quot;3) &quot;python&quot;127.0.0.1:6379&gt; sismember books java(integer) 1127.0.0.1:6379&gt; scard books(integer) 3# 获取长度127.0.0.1:6379&gt; spop books&quot;python&quot;# 弹出一个 zset(有序集合)zset是redis提供的最有特色的数据结构，它类似于Java的SortedSet和HashMap的结合体。每个元素都会关联一个double类型的分数，分数(score)代表元素的排序权重。 1234567891011121314151617181920212223127.0.0.1:6379&gt; zadd book 9.0 &quot;think in java&quot;(integer) 1127.0.0.1:6379&gt; del book(integer) 1127.0.0.1:6379&gt; zadd books 9.0 &quot;think in java&quot;(integer) 1127.0.0.1:6379&gt; zadd books 8.9 &quot;java cookbook&quot;(integer) 1127.0.0.1:6379&gt; zadd books 8.6 &quot;java concurrency&quot;(integer) 1127.0.0.1:6379&gt; zrange books 0 -11) &quot;java concurrency&quot;2) &quot;java cookbook&quot;3) &quot;think in java&quot;127.0.0.1:6379&gt; zrevrange books 0 -11) &quot;think in java&quot;2) &quot;java cookbook&quot;3) &quot;java concurrency&quot;127.0.0.1:6379&gt; zrangebyscore books -inf 8.91 withscores1) &quot;java concurrency&quot;2) &quot;8.5999999999999996&quot;3) &quot;java cookbook&quot;4) &quot;8.9000000000000004&quot; Redis相关命令 redis相关设置123456789101112131415161718127.0.0.1:6379&gt; config set requirepass test123127.0.0.1:6379&gt; auth test123127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;test123&quot;# 如果配置文件中没添加密码 那么redis重启后，密码失效127.0.0.1:6379&gt; info# 查看相关信息# 查看数据的数量localhost:6379&gt; config get databases1) &quot;databases&quot;2) &quot;16&quot; # 16个数据库 连接到redis服务12# 格式 $ redis-cli -h host -p port -a password$ redis-cli -h 127.0.0.1 -p 6379 -a &quot;test123&quot; key相关命令 序号 命令及描述 1 DEL key 该命令用于在 key 存在是删除 key。 2 DUMP key 序列化给定 key ，并返回被序列化的值。 3 EXISTS key 检查给定 key 是否存在。 4 EXPIRE key seconds 为给定 key 设置过期时间。 5 EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 6 PEXPIRE key milliseconds 设置 key 的过期时间亿以毫秒计。 7 PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 8 KEYS pattern 查找所有符合给定模式( pattern)的 key 。 9 MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。 10 PERSIST key 移除 key 的过期时间，key 将持久保持。 11 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。 12 TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 13 RANDOMKEY 从当前数据库中随机返回一个 key 。 14 RENAME key newkey 修改 key 的名称 15 RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。 16 TYPE key 返回 key 所储存的值的类型。 字符串(String) 序号 命令及描述 1 SET key value 设置指定 key 的值 2 GET key 获取指定 key 的值。 3 GETRANGE key start end 返回 key 中字符串值的子字符 4 GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 5 GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 6 MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。 7 SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 8 SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 9 SETNX key value 只有在 key 不存在时设置 key 的值。 10 SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 11 STRLEN key 返回 key 所储存的字符串值的长度。 12 MSET key value [key value …] 同时设置一个或多个 key-value 对。 13 MSETNX key value [key value …] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 14 PSETEX key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 15 INCR key 将 key 中储存的数字值增一。 16 INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。 17 INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。 18 DECR key 将 key 中储存的数字值减一。 19 DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。 20 APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 字典(hash) 序号 命令及描述 1 HDEL key field2 [field2] 删除一个或多个哈希表字段 2 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 3 HGET key field 获取存储在哈希表中指定字段的值&#x2F;td&gt; 4 HGETALL key 获取在哈希表中指定 key 的所有字段和值 5 HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 6 HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 7 HKEYS key 获取所有哈希表中的字段 8 HLEN key 获取哈希表中字段的数量 9 HMGET key field1 [field2] 获取所有给定字段的值 10 HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 11 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。 12 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 13 HVALS key 获取哈希表中所有值 14 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 列表(list) 序号 命令及描述 1 BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 2 BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 3 BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 4 LINDEX key index 通过索引获取列表中的元素 5 LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素 6 LLEN key 获取列表长度 7 LPOP key 移出并获取列表的第一个元素 8 LPUSH key value1 [value2] 将一个或多个值插入到列表头部 9 LPUSHX key value 将一个或多个值插入到已存在的列表头部 10 LRANGE key start stop 获取列表指定范围内的元素 11 LREM key count value 移除列表元素 12 LSET key index value 通过索引设置列表元素的值 13 LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 14 RPOP key 移除并获取列表最后一个元素 15 RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 16 RPUSH key value1 [value2] 在列表中添加一个或多个值 17 RPUSHX key value 为已存在的列表添加值 集合(set) 序号 命令及描述 1 SADD key member1 [member2] 向集合添加一个或多个成员 2 SCARD key 获取集合的成员数 3 SDIFF key1 [key2] 返回给定所有集合的差集 4 SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中 5 SINTER key1 [key2] 返回给定所有集合的交集 6 SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中 7 SISMEMBER key member 判断 member 元素是否是集合 key 的成员 8 SMEMBERS key 返回集合中的所有成员 9 SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合 10 SPOP key 移除并返回集合中的一个随机元素 11 SRANDMEMBER key [count] 返回集合中一个或多个随机数 12 SREM key member1 [member2] 移除集合中一个或多个成员 13 SUNION key1 [key2] 返回所有给定集合的并集 14 SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中 15 SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素 有序集合(zset) 序号 命令及描述 1 ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 2 ZCARD key 获取有序集合的成员数 3 ZCOUNT key min max计算在有序集合中指定区间分数的成员数 4 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment 5 ZINTERSTORE destination numkeys key [key …] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 6 ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 7 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合成指定区间内的成员 8 ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员 9 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员 10 ZRANK key member 返回有序集合中指定成员的索引 11 ZREM key member [member …] 移除有序集合中的一个或多个成员 12 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 13 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 14 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 15 ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到底 16 ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序 17 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 18 ZSCORE key member 返回有序集中，成员的分数值 19 ZUNIONSTORE destination numkeys key [key …] 计算给定的一个或多个有序集的并集，并存储在新的 key 中 20 ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"开发/数据库","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://jingyu.life/tags/Redis/"}]},{"title":"mysql中的时间函数以及格式问题","slug":"db/mysql/time-func","date":"2020-09-14T05:54:54.000Z","updated":"2023-03-13T16:04:28.289Z","comments":false,"path":"2020/09/14/db/mysql/time-func/","link":"","permalink":"https://jingyu.life/2020/09/14/db/mysql/time-func/","excerpt":"之前在开发过程中， 碰到数据库关于时间的问题，总是要去搜索一下， 自己简单记录一下常用的吧，后面遇到啥新鲜的玩意， 再加上。","text":"之前在开发过程中， 碰到数据库关于时间的问题，总是要去搜索一下， 自己简单记录一下常用的吧，后面遇到啥新鲜的玩意， 再加上。 时间函数 获取当前日期和时间123456789101112131415161718192021mysql&gt; SELECT CURDATE(), CURRENT_DATE, CURTIME(), CURRENT_TIME;+------------+--------------+-----------+--------------+| CURDATE() | CURRENT_DATE | CURTIME() | CURRENT_TIME |+------------+--------------+-----------+--------------+| 2020-09-14 | 2020-09-14 | 14:34:00 | 14:34:00 |+------------+--------------+-----------+--------------+mysql&gt; SELECT NOW(), CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP;+---------------------+---------------------+---------------------+| NOW() | CURRENT_TIMESTAMP() | CURRENT_TIMESTAMP |+---------------------+---------------------+---------------------+| 2020-09-14 14:35:23 | 2020-09-14 14:35:23 | 2020-09-14 14:35:23 |+---------------------+---------------------+---------------------+-- 获取系统时间mysql&gt; SELECT SYSDATE();+---------------------+| SYSDATE() |+---------------------+| 2020-09-14 15:20:25 |+---------------------+ 获取当前时间的各个信息，如月份、一年第几周123456mysql&gt; SELECT WEEK(NOW()), WEEK(&#x27;2020-01-01&#x27;), DAY(CURRENT_TIMESTAMP()), DAY(&#x27;2019-12-12 13:23:57&#x27;), YEAR(NOW()), MONTH(NOW());+-------------+--------------------+--------------------------+----------------------------+-------------+--------------+| WEEK(NOW()) | WEEK(&#x27;2020-01-01&#x27;) | DAY(CURRENT_TIMESTAMP()) | DAY(&#x27;2019-12-12 13:23:57&#x27;) | YEAR(NOW()) | MONTH(NOW()) |+-------------+--------------------+--------------------------+----------------------------+-------------+--------------+| 37 | 0 | 14 | 12 | 2020 | 9 |+-------------+--------------------+--------------------------+----------------------------+-------------+--------------+ 关于时间戳转换123456mysql&gt; SELECT UNIX_TIMESTAMP(), UNIX_TIMESTAMP(&#x27;2020-05-01 13:29:57&#x27;), FROM_UNIXTIME(1600066964), FROM_UNIXTIME(1600066964, &#x27;%m/%d/%Y&#x27;);+------------------+---------------------------------------+---------------------------+---------------------------------------+| UNIX_TIMESTAMP() | UNIX_TIMESTAMP(&#x27;2020-05-01 13:29:57&#x27;) | FROM_UNIXTIME(1600066964) | FROM_UNIXTIME(1600066964, &#x27;%m/%d/%Y&#x27;) |+------------------+---------------------------------------+---------------------------+---------------------------------------+| 1600067106 | 1588310997 | 2020-09-14 15:02:44 | 09/14/2020 |+------------------+---------------------------------------+---------------------------+---------------------------------------+ 自己提取时间中的信息12345678-- 格式 SELECT EXTRACT(unit FROM date)-- eg.SELECT EXTRACT((SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR|MICROSECOND|YEAR_DAY) FROM NOW())mysql&gt; select extract(MONTH FROM NOW()), EXTRACT(YEAR FROM &#x27;2019-12-31&#x27;), EXTRACT(YEAR_MONTH FROM &#x27;2019-12-31&#x27;);+---------------------------+---------------------------------+---------------------------------------+| extract(MONTH FROM NOW()) | EXTRACT(YEAR FROM &#x27;2019-12-31&#x27;) | EXTRACT(YEAR_MONTH FROM &#x27;2019-12-31&#x27;) |+---------------------------+---------------------------------+---------------------------------------+| 9 | 2019 | 201912 |+---------------------------+---------------------------------+---------------------------------------+ 日期运算123456789101112131415161718192021222324252627282930313233-- DATE_ADD(date,INTERVAL expr type) 日期加上时间区间-- eg. DATE_ADD(now(), INTERVAL expr(YEAR|DAY|...|YEAR_MONTH|DAY_HOUR|DAY_MINUTE|DAY_SECOND|HOUR_SECOND))mysql&gt; SELECT DATE_ADD(&#x27;2020-05-01 00:01:01&#x27;, interval &#x27;1 1:20:29&#x27; day_second);+------------------------------------------------------------------+| DATE_ADD(&#x27;2020-05-01 00:01:01&#x27;, interval &#x27;1 1:20:29&#x27; day_second) |+------------------------------------------------------------------+| 2020-05-02 01:21:30 |+------------------------------------------------------------------+-- DATE_SUB(date,INTERVAL expr type) 日期减去时间区间mysql&gt; SELECT DATE_SUB(&#x27;2020-05-02 01:21:30 &#x27;, interval &#x27;1 1:20:29&#x27; day_second);+-------------------------------------------------------------------+| DATE_SUB(&#x27;2020-05-02 01:21:30 &#x27;, interval &#x27;1 1:20:29&#x27; day_second) |+-------------------------------------------------------------------+| 2020-05-01 00:01:01 |+-------------------------------------------------------------------+-- DATEDIFF(date1, date2) 日期相减mysql&gt; SELECT DATEDIFF(&#x27;2020-05-03&#x27;, &#x27;2020-05-01&#x27;), DATEDIFF(&#x27;2020-05-03 12:23:33&#x27;, &#x27;2020-05-01 12:22:33&#x27;);+--------------------------------------+--------------------------------------------------------+| DATEDIFF(&#x27;2020-05-03&#x27;, &#x27;2020-05-01&#x27;) | DATEDIFF(&#x27;2020-05-03 12:23:33&#x27;, &#x27;2020-05-01 12:22:33&#x27;) |+--------------------------------------+--------------------------------------------------------+| 2 | 2 |+--------------------------------------+--------------------------------------------------------+-- TIMEDIFF(time1, time2)-- 注意两个日期类型的相减，默认是0mysql&gt; SELECT TIMEDIFF(&#x27;12:23:33&#x27;, &#x27;12:22:23&#x27;),TIMEDIFF(&#x27;2020-05-03&#x27;, &#x27;2020-05-01&#x27;), TIMEDIFF(&#x27;2020-05-03 12:23:33&#x27;, &#x27;2020-05-01 12:22:33&#x27;);+----------------------------------+--------------------------------------+--------------------------------------------------------+| TIMEDIFF(&#x27;12:23:33&#x27;, &#x27;12:22:23&#x27;) | TIMEDIFF(&#x27;2020-05-03&#x27;, &#x27;2020-05-01&#x27;) | TIMEDIFF(&#x27;2020-05-03 12:23:33&#x27;, &#x27;2020-05-01 12:22:33&#x27;) |+----------------------------------+--------------------------------------+--------------------------------------------------------+| 00:01:10 | 00:00:00 | 48:01:00 |+----------------------------------+--------------------------------------+--------------------------------------------------------+ 时间格式转化 STR_TO_DATE()1234567891011121314151617-- 将字符串格式的时间转化为日期类型-- STR_TO_DATE(str, format)mysql&gt; SELECT STR_TO_DATE(&#x27;08,23,20&#x27;, &#x27;%m,%d,%y&#x27;) , STR_TO_DATE(&#x27;05/21/2020 12:23:33&#x27;, &#x27;%m/%d/%Y %H:%i:%s&#x27;), STR_TO_DATE(&#x27;21,5,2020 extra characters&#x27;,&#x27;%d,%m,%Y&#x27;);+-------------------------------------+---------------------------------------------------------+------------------------------------------------------+| STR_TO_DATE(&#x27;08,23,20&#x27;, &#x27;%m,%d,%y&#x27;) | STR_TO_DATE(&#x27;05/21/2020 12:23:33&#x27;, &#x27;%m/%d/%Y %H:%i:%s&#x27;) | STR_TO_DATE(&#x27;21,5,2020 extra characters&#x27;,&#x27;%d,%m,%Y&#x27;) |+-------------------------------------+---------------------------------------------------------+------------------------------------------------------+| 2020-08-23 | 2020-05-21 12:23:33 | 2020-05-21 |+-------------------------------------+---------------------------------------------------------+------------------------------------------------------+-- 看看格式化值为NULL的例子mysql&gt; SELECT STR_TO_DATE(&#x27;2020&#x27;,&#x27;%Y&#x27;), STR_TO_DATE(&#x27;202005&#x27;, &quot;%Y%m&quot;) , STR_TO_DATE(&#x27;11&#x27;, &#x27;%h&#x27;), STR_TO_DATE(&#x27;122223&#x27;, &#x27;%H%i%s&#x27;);+--------------------------+-------------------------------+-------------------------+---------------------------------+| STR_TO_DATE(&#x27;2020&#x27;,&#x27;%Y&#x27;) | STR_TO_DATE(&#x27;202005&#x27;, &quot;%Y%m&quot;) | STR_TO_DATE(&#x27;11&#x27;, &#x27;%h&#x27;) | STR_TO_DATE(&#x27;122223&#x27;, &#x27;%H%i%s&#x27;) |+--------------------------+-------------------------------+-------------------------+---------------------------------+| NULL | NULL | NULL | NULL |+--------------------------+-------------------------------+-------------------------+---------------------------------+ DATE_FROMAT()12345678-- 将标准格式转化为自己想要的格式-- DATE_FORMAT(date, format)mysql&gt; SELECT DATE_FORMAT(now(), &#x27;%m/%d/%Y&#x27;), DATE_FORMAT(&#x27;2019-05-01 12:22:33&#x27;, &#x27;%m,%d,%Y, %H-%i-%s&#x27;);+--------------------------------+----------------------------------------------------------+| DATE_FORMAT(now(), &#x27;%m/%d/%Y&#x27;) | DATE_FORMAT(&#x27;2019-05-01 12:22:33&#x27;, &#x27;%m,%d,%Y, %H-%i-%s&#x27;) |+--------------------------------+----------------------------------------------------------+| 09/14/2020 | 05,01,2019, 12-22-33 |+--------------------------------+----------------------------------------------------------+","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"开发/数据库","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jingyu.life/tags/Mysql/"}]},{"title":"mysql基础用法","slug":"db/mysql/basic-usage","date":"2020-09-12T05:54:54.000Z","updated":"2023-03-13T16:04:28.289Z","comments":false,"path":"2020/09/12/db/mysql/basic-usage/","link":"","permalink":"https://jingyu.life/2020/09/12/db/mysql/basic-usage/","excerpt":"不知道写啥， 简单记录一下数据库的相关操作吧，结合实例","text":"不知道写啥， 简单记录一下数据库的相关操作吧，结合实例 数据库 用户、权限、密码问题 1234567891011121314151617181920212223242526272829303132333435363738394041-- 新建用户CREATE USER &#x27;username&#x27;@&#x27;hostname&#x27; IDENTIFIED BY &#x27;password&#x27;;-- 修改用户名UPDATE mysql.`user` set `user` = &#x27;new_username&#x27; WHERE `user` = &#x27;username&#x27;;RENAME USER &#x27;username&#x27;@&#x27;hostname&#x27; TO &#x27;new_username&#x27;@&#x27;new_hostname&#x27;;FLUSH PRIVILEGES;-- 用户密码修改SET PASSWORD FOR (username)=password(&#x27;new_password&#x27;);UPDATE mysql.`user` set `authentication_string`=password(&#x27;new_password&#x27;) where `user`=&#x27;userna me&#x27;; # 5.7版本后用 authentication_string ，之前是 password字段# 修改完后 FLUSH PRIVILEGES;-- 删除用户DELETE FROM myql.`user` WHERE `user` = &#x27;username&#x27; AND `host` = &#x27;hostname&#x27;;DROP USER &#x27;username&#x27;@&#x27;hostname&#x27;;-- GRANT 命令格式GRANT privileges ON databases.tablename TO &#x27;username&#x27;@&#x27;hostname&#x27; [INDENTIFIED BY &#x27;password&#x27;]; FLUSH PRIVILEGES;# 当使用 INDENTIFIED BY 时， 没有改用户，则会创建一个用户-- 查看用户权限SHOW GRANTS FOR &#x27;username&#x27;@&#x27;hostname&#x27;;-- GRANT 命令创建用户GRANT (privileges) ON *.* TO &#x27;username&#x27;@&#x27;hostname&#x27; IDENTIFIED BY &#x27;password&#x27;;# eg. grant select on *.* to &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;# *.* -&gt; database_name.table_name-- 设置用户访问权限GRANT (ALL PRIVILEGES) ON databases.tablename to &#x27;username&#x27;@&#x27;hostname&#x27; [IDENTIFIED BY &#x27;password&#x27;] [WITH GRANT OPTION] ;# ALL PRIVILEGES 可以替换为 select , update , insert , delete 其中之一或组合, 还有其他的，自己搜吧# WITH GRANT OPTION 加上表示给改用户添加赋权的权限# eg. grant select,update on *.* to &#x27;test&#x27;@&#x27;%&#x27; with grant option-- 回收权限REVOKE (ALL PRIVILEGES) ON databases.tablename FROM &#x27;username&#x27;@&#x27;hostname&#x27;# ALL PRIVILEGES -&gt; select , update , insert , delete and ...# eg. revoke update, grant option on *.* from &#x27;test&#x27;@&#x27;%&#x27; 数据库新建&amp;删除 123456-- 查看SHOW DATABASES;-- 创建CREATE DATABASE `test` DEFAULT CHARACTER SET utf8mb4;-- 删除DROP DATABASE `test` 数据表 说明： 在上面创建的test数据库中创建三张表， teacher(教师表)， students(学生表)， class(班级表) Teachers (t_id, name, age, sex, email, phone) Students(stu_id, name, age, sex, class_id) Class(id, name, t_id) t_id -&gt; 班主任 name其实可以细化为 年级号、 班号啥的 创建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455-- teachersCREATE TABLE IF NOT EXISTS `teachers`( `t_id` INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;&#x27;, `sex` TINYINT(1) NOT NULL DEFAULT 0 COMMENT &#x27;0 -&gt; 女; 1 -&gt; 男&#x27;, `age` TINYINT NOT NULL DEFAULT 0, `phone` VARCHAR(20) NOT NULL DEFAULT &#x27;&#x27;, `email` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27;, `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); -- classCREATE TABLE IF NOT EXISTS `class`( `id` INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;&#x27;, `t_id` INT NOT NULL DEFAULT 0, `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP);-- students;CREATE TABLE IF NOT EXISTS `students`( `stu_id` INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;&#x27;, `sex` TINYINT(1) NOT NULL DEFAULT 0 COMMENT &#x27;0 -&gt; 女; 1 -&gt; 男&#x27;, `age` TINYINT NOT NULL DEFAULT 0, `class_id` INT NOT NULL DEFAULT 0, `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP);-- 查看创建的表mysql&gt; SHOW TABLES;+----------------+| Tables_in_test |+----------------+| class || students || teachers |+----------------+mysql&gt; DESC teachers;+------------+------------------+------+-----+-------------------+-----------------------------+| Field | Type | Null | Key | Default | Extra |+------------+------------------+------+-----+-------------------+-----------------------------+| t_id | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(30) | NO | | | || sex | tinyint(1) | NO | | 0 | || age | tinyint(4) | NO | | 0 | || phone | varchar(20) | NO | | | || email | varchar(50) | NO | | | || created_at | timestamp | NO | | CURRENT_TIMESTAMP | || updated_at | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |+------------+------------------+------+-----+-------------------+-----------------------------+ 修改123456789101112131415-- 改表名ALTER TABLE `table` RENAME TO `new_table_name`;-- 添加字段ALTER TABLE `table` ADD [COLUMN] `column` ···-- ALTER TABLE `table_name` ADD COLUMN `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP-- 修改字段ALTER TABLE `table` MODIFY [COLUMN] `column` ···-- 字段改名ALTER TABLE `table` CHANGE `column` `new_column` ···-- 删除字段ALTER TABLE `table` DROP COLUMN `column` 删除1DROP TABLE `table_name` 数据表的操作 增123456789101112131415-- 向teacher表插入数据INSERT INTO `teachers`(`name`, `sex`, `age`) VALUES (&#x27;teacher1&#x27;, 0, 35),(&#x27;teacher2&#x27;, 0, 30),(&#x27;teacher3&#x27;, 1, 35),(&#x27;teacher4&#x27;, 0, 37),(&#x27;teacher5&#x27;, 0, 35),(&#x27;teacher6&#x27;, 1, 29),(&#x27;teacher7&#x27;, 0, 35),(&#x27;teacher8&#x27;, 0, 27),(&#x27;teacher9&#x27;, 1, 35),(&#x27;teacher10&#x27;, 0, 43);-- 向class表插入数据INSERT INTO `class`(`name`, `t_id`) VALUES(&#x27;class1&#x27;, 1),(&#x27;class2&#x27;, 7),(&#x27;class3&#x27;, 6),(&#x27;class4&#x27;, 9),(&#x27;class5&#x27;, 4);-- 向students表插入数据INSERT INTO `students`(`name`, `sex`, `age`, `class_id`) VALUES (&#x27;stu1&#x27;, 0, 17, 1),(&#x27;stu2&#x27;, 1, 16, 3),(&#x27;stu3&#x27;, 1, 17, 4),(&#x27;stu4&#x27;, 0, 16, 3),(&#x27;stu5&#x27;, 0, 17, 3),(&#x27;stu6&#x27;, 1, 17, 5),(&#x27;stu6&#x27;, 0, 16, 3),(&#x27;stu8&#x27;, 1, 18, 2),(&#x27;stu9&#x27;, 0, 17, 3),(&#x27;stu10&#x27;, 1, 16, 4),(&#x27;stu11&#x27;, 1, 17, 3),(&#x27;stu12&#x27;, 0, 17, 2),(&#x27;stu13&#x27;, 0, 18, 1),(&#x27;stu14&#x27;, 1, 17, 5),(&#x27;stu15&#x27;, 0, 18, 4),(&#x27;stu16&#x27;, 0, 17, 3),(&#x27;stu17&#x27;, 1, 18, 2),(&#x27;stu17&#x27;, 0, 17, 2),(&#x27;stu19&#x27;, 0, 17, 5),(&#x27;stu20&#x27;, 1, 18, 4),(&#x27;stu21&#x27;, 1, 16, 3),(&#x27;stu22&#x27;, 0, 17, 3),(&#x27;stu23&#x27;, 0, 17, 1),(&#x27;stu24&#x27;, 1, 16, 3),(&#x27;stu25&#x27;, 1, 17, 1),(&#x27;stu26&#x27;, 0, 18, 3),(&#x27;stu27&#x27;, 1, 17, 4),(&#x27;stu28&#x27;, 0, 16, 3),(&#x27;stu29&#x27;, 0, 17, 4),(&#x27;stu39&#x27;, 1, 18, 3);-- 创建好的表， 自己做一个备份吧，后面可能要还原数据 删12-- 简单删除DELETE FROM teachers WHERE t_id = 10; 改12-- 简单更改UPDATE `teachers` SET email = &#x27;test@gmail.com&#x27; WHERE `name` = &#x27;teacher3&#x27; 查1234-- 简单查询SELECT * FROM `teachers`; SELECT `name`, class_id FROM `students`; 按需完成相关操作 查询每个班的班主任信息 12345SELECT * FROM `teachers` WHERE t_id IN ( SELECT t_id FROM `class` );SELECT teachers.* FROM `class` JOIN `teachers` on class.t_id = `teachers`.t_id ; 查询每个班的人数 1SELECT a.id, a.`name`, count(b.class_id) FROM `class` AS a LEFT JOIN `students` AS b ON a.id = b.class_id GROUP BY a.id ; 查询每个班主任所带班级的平均年龄, 包括班主任信息 1234SELECT a.t_id, a.`name`, a.`age`, a.`sex`, a.`email`, a.`phone`, b.`name` as class_name, avg(c.`age`) as class_avg_age FROM `teachers` as aJOIN `class` as b on a.t_id = b.t_idJOIN `students` as c on b.id = c.class_idGROUP BY a.t_id,b.id ; 将teacher4老师所带班级的名叫stu6的学生的年纪修改为18岁 123456-- 多表连接更新UPDATE teachers as a JOIN class as b on a.t_id = b.t_idJOIN students as c on b.id = c.class_idSET c.age = 18WHERE a.`name` = &#x27;teacher4&#x27; and c.`name` = &#x27;stu6&#x27; 将teacher6老师所带班级的名叫stu39的学生的记录删除 12345-- 多表连接删除DELETE c from teachers as a JOIN class as b on a.t_id = b.t_idJOIN students as c on b.id = c.class_idWHERE a.`name` = &#x27;teacher6&#x27; and c.`name` = &#x27;stu39&#x27; mmp ， 先写这么多吧，后面用到了在加上。","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"开发/数据库","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jingyu.life/tags/Mysql/"}]},{"title":"git 子模块","slug":"git/git-submodule","date":"2020-08-26T09:57:39.000Z","updated":"2023-02-21T13:12:07.443Z","comments":false,"path":"2020/08/26/git/git-submodule/","link":"","permalink":"https://jingyu.life/2020/08/26/git/git-submodule/","excerpt":"经常碰到这种情况：当你在一个Git 项目上工作时，你需要在其中使用另外一个Git 项目。也许它是一个第三方开发的Git 库或者是你独立开发和并在多个父项目中使用的。这个情况下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。 这时候 submodule 就上场了！","text":"经常碰到这种情况：当你在一个Git 项目上工作时，你需要在其中使用另外一个Git 项目。也许它是一个第三方开发的Git 库或者是你独立开发和并在多个父项目中使用的。这个情况下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。 这时候 submodule 就上场了！ 添加子模块1234567891011# 直接clone，会在当前目录生成一个对应子目录存放仓库内容$ git submodule add &lt;submodule_url&gt; [path/submoduleName]# 初始化本地.gitmodules文件$ git submodule init # 同步远端submodule源码$ git submodule update # 获取主项目和所有子项目源码$ git clone --recurse-submodules &lt;main_project_url&gt; 查看 &amp; 更新12345678# 查看子模块$ git submodule# 更新项目内子模块到最新版本$ git submodule update# 更新子模块为远程项目的最新版本$ git submodule update --remote 删除子模块12345678910# 1、 删除子模块文件夹$ git rm --cached &lt;submodule&gt;$ rm -rf &lt;submodule&gt;# 2、删除.gitmodules文件中相关子模块信息# 3、删除.git/config中的相关子模块信息# 4、删除.git文件夹中的相关子模块文件$ rm -rf .git/modules/&lt;submodule&gt; 同步 向上同步12345# 当子模块有未被使用的新提交时（例如在 sub-module.git 中执行 git pull --rebase 拉取新的内容后），git 会给予提示# 将子模块的内容同步到主仓库，只需要在主仓库中创建一个新的提交即可$ git add submodule$ git commit -m &quot;message&quot; 向下同步12# 主要是更新$ git submodule update 注意点 当子模块有提交的时候,没有push到远程仓库, 父级引用子模块的commit更新,并提交到远程仓库, 当别人拉取代码的时候就会报出子模块的commit不存在 fatal: reference isn’t a tree 。 如果你仅仅引用了别人的子模块的游离分支,然后在主仓库修改了子仓库的代码,之后使用git submodule update拉取了最新代码,那么你在子仓库游离分支做出的修改会被覆盖掉。 我们假设你一开始在主仓库并没有采用子模块的开发方式,而是在另外的开发分支使用了子仓库,那么当你从开发分支切回到没有采用子模块的分支的时候,子模块的目录并不会被Git自动删除,而是需要你手动的删除了。","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://jingyu.life/tags/Git/"}]},{"title":"git学习篇","slug":"git/git-usage","date":"2020-08-09T05:54:54.000Z","updated":"2023-02-21T13:12:07.444Z","comments":false,"path":"2020/08/09/git/git-usage/","link":"","permalink":"https://jingyu.life/2020/08/09/git/git-usage/","excerpt":"本文不是记录所有的命令， 会将部分命令做一个简易说明 ​","text":"本文不是记录所有的命令， 会将部分命令做一个简易说明 ​ 看懂上面的流程， 就可以大致知道自己要进行什么操作，以及怎样操作 安装 安装的话， 自己搜一下吧， 问题应该不大 新建​ 12345# 在当前目录下新建一个代码库 [新建一个目录， 初始化为代码库]$ git init [project-name]# 远程拷贝一个项目 , 克隆到本地$ git clone &lt;git-repo-url&gt; [project-name] 配置12345678910111213141516# 查看 config$ git config --list# 编辑 config$ git config -e [--global]# 修改用户信息$ git config [--global] user.name &quot;Your Name&quot;$ git config [--global] user.email &quot;email@example.com&quot;# 命令别名$ git config --global alias.st status$ git config --global alias.co checkout$ git config --global alias.ci commit# 个人喜欢将常用的 commit 简写为 ci， checkout简写为 co# --global 是全局配置， 不加上只能在对应的git 目录下使用 常用命令123456789101112131415161718192021222324252627# 查看工作区和暂存区的状态$ git status # 将工作区的文件提交到暂存区$ git add . # 提交到本地仓库$ git commit -m &quot;本次提交说明&quot;# add和commit的合并，便捷写法（未追踪的文件无法直接提交到暂存区/本地仓库）$ git commit -am &quot;本次提交说明&quot; # 将本地分支和远程分支进行关联$ git push -u origin branchName # 将本地仓库的文件推送到远程分支$ git push# 拉取远程分支的代码$ git pull origin branchName # 合并分支$ git merge branchName # 查看本地拥有哪些分支$ git branch# 查看所有分支（包括远程分支和本地分支）$ git branch -a # 切换分支$ git checkout branchName # 临时将工作区文件的修改保存至堆栈中, 我个人是不太喜欢用stash的， 习惯是切换到另一个分支，保存结点。 毕竟不小心# 删除 stash中的内容， 找回也挺麻烦的$ git stash# 将之前保存至堆栈中的文件取出来$ git stash pop 其它命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149## rm# 删除暂存区和工作区的文件$ git rm [filename]# 只删除暂存区的文件，不会删除工作区的文件, 停止追踪文件(后面将其添加至gitignore)$ git rm --cached [filename]## commit# 补充提交, 提交至上一个结点中$ git commit --amend [message] $ git commit --amend -no-edit# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]## push &amp; pull &amp; fetch# 将本地仓库的文件推送到远程分支# 如果远程仓库没有这个分支，会新建一个同名的远程分支# 如果省略远程分支名，则表示两者同名$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 拉取并合并项目其他人员的一个分支 $ git pull origin branchname # 等同于 fetch + merge$ git fetch origin branchName$ git merge origin/branchName# 强推， 覆盖远程结点$ git push -f## branch# 查看本地分支[-r 远程， -a 本地和远程]$ git branch [-r, -a]# 新建分支, 可以指向某个提交结点$ git branch &lt;branchName&gt; [commit]# 切换分支$ git checkout &lt;branchName&gt;# 新建并切换$ git checkout -b &lt;branchName&gt;# 删除分支# 删除本地 [-d 被删除的分支上有没有合并的结点会阻止, -D 强制删除分支 ]$ git branch [-d, -D] &lt;branchName&gt;# 删除远程分支$ git push &lt;远程主机名&gt; :&lt;远程分支名&gt;$ git push &lt;远程主机名&gt; --delete &lt;远程分支名&gt;$ git branch -dr &lt;remote/branch&gt;## diff# 查看工作区和暂存区所有文件的对比[单个文件的对比]$ git diff [fileName]# 1.你修改了某个文件，但是没有提交到暂存区，这时候会有对比的内容# 一旦提交到暂存区，就不会有对比的内容(因为暂存区已经更新)# 2.如果你新建了一个文件，但是没有提交到暂存区，这时候 diff 是没有结果的# 查看暂存区与上次提交到本地仓库的快照（即最新提交到本地仓库的快照）的对比$ git diff --cached/--staged# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 查看本地两个分支的所有的对比[单个文件的对比]$ git diff &lt;branchName1&gt; &lt;branchName2&gt; [fileName]# 查看远程分支和远程分支[本地分支]的对比 或 单个文件$ git diff &lt;远程主机名/branchname1&gt; &lt;远程主机名/branchname2 | branchname2&gt; [filenName]# 查看两个 commit 的对比$ git diff commit1 commit2 # 一个有意思的命令, 查看自己写了多少代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;## blame 谁动了你的面包, 甩锅大法# 显示指定文件是什么人在什么时间修改过$ git blame [fileName]## log# 查看提交历史$ git log --oneline --grep=&quot;关键字&quot; --graph --all --author &quot;username&quot; --reverse -num -p --before= 1 day/1 week/1 &quot;2019-06-06&quot; --after= &quot;2019-06-06&quot; --stat --abbrev-commit --pretty=format:&quot;xxx&quot; # oneline -&gt; 将日志记录一行一行的显示# grep=&quot;关键字&quot; -&gt; 查找日志记录中(commit提交时的注释)与关键字有关的记录# graph -&gt; 记录图形化显示 ！！！ # all -&gt; 将所有记录都详细的显示出来# author &quot;username&quot; -&gt; 查找这个作者提交的记录# reverse -&gt; commit 提交记录顺序翻转 # before -&gt; 查找规定的时间(如:1天/1周)之前的记录 # num -&gt; git log -10 显示最近10次提交 ！！！ # stat -&gt; 显示每次更新的文件修改统计信息，会列出具体文件列表 ！！！# abbrev-commit -&gt; 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 ！！！# pretty=format:&quot;xxx&quot; -&gt; 可以定制要显示的记录格式 ！！！# p -&gt; 显示每次提交所引入的差异（按 补丁 的格式输出）！！！# 常用$ git log --graph [--stat]# 查看本地 git 命令历史, 常用来恢复某些失误的操作$ git reflog## show# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]## tag# 列出所有tag$ git tag# 新建一个tag在指定commit, 可以指定说明文字$ git tag [tag] [commit] [-m &quot;message&quot;]# 查看单个标签具体信息$ git show &lt;tagname&gt;# 推送一个本地标签$ git push &lt;远程主机名&gt; &lt;tagname&gt;# 推送全部未推送过的本地标签$ git push &lt;远程主机名&gt; --tags# 删除本地tag$ git tag -d [tag]# 删除远程tag, 有点像删除远程分支$ git push &lt;远程主机名&gt; :refs/tags/&lt;tagname&gt; ## remote# 查看所有远程主机$ git remote# 查看关联的远程仓库的详细信息$ git remote -v # 删除远程仓库的 “关联”$ git remote rm &lt;远程主机名&gt; # 添加远程仓库的 “关联”$ git remote add &lt;远程主机名&gt; &lt;remote-url&gt;# 设置远程仓库的 “关联”$ git remote set-url &lt;远程主机名&gt; &lt;newurl&gt; 单读讲讲 分支合并 merge 12345# 将另外一个分支合并到当前分支，主要是合并到master$ git merge &lt;branchName&gt; [--fast-forward | --no-ff | --squash]# --fast-forward: 会在当前分支的提交历史中添加进被合并分支的提交历史# --no-ff: 会生成一个新的提交，让当前分支的提交历史不会那么乱# --squash: 不会生成新的提交，会将被合并分支多次提交的内容直接存到工作区和暂存区，由开发者手动去提交，这样当前分支最终只会多出一条提交记录，不会掺杂被合并分支的提交历史 rebase 关于rebase 的示意图， 看看这篇文章吧 12345678910111213141516171819# 将master分支中的修改添加到master分支上(保证当前分支的修改， 是基于master分支上的修改)$ git checkout &lt;branchName&gt;$ git rebase master# 或者直接使用$ git rebase &lt;branchName1&gt; &lt;branchName2&gt;# 对当前分支提交的 startpoint -&gt; endpoint (前开后闭) 提交记录进行整理$ git rebase -i [startpoint] [endpoint]# pick：保留该commit（缩写:p）# reword：保留该commit，但我需要修改该commit的注释（缩写:r）# edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）# squash：将该commit和前一个commit合并（缩写:s）# fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）# exec：执行shell命令（缩写:x）# drop：我要丢弃该commit（缩写:d）# 选择特定的结点到指定分支(区间前开后闭), 建议使用 cherry-pick$ git rebase [startpoint] [endpoint] --onto master# 注意: 添加过去的结点， 还处于游离状态(HEAD没有处于最新结点) ， 可以新建一个分支或直接使用 reset --hard cherry-pick 12345678# 将提交的结点 添加到当前分支，会产生一个新的提交(哈希值不一样)$ git cherry-pick &lt;commitHash&gt;# 将另外一个分支上最新提交的结点添加到当前分支$ git cherry-pick &lt;branchName&gt;# 转移多个提交$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;# 转移一系列提交（区间， 左开右闭）$ git cherry-pick &lt;HashA&gt;^..&lt;HashB&gt; 关于cherry-pick, 参考这里 撤销&amp;回退123456789101112131415161718192021222324252627282930313233343536373839404142# 原来的命令# 撤销工作区修改的文件, 还未提交到暂存区$ git checkout filname# 撤销暂存区的文件$ git reset HEAD filename## checkout# 恢复暂存区的指定文件到工作区$ git checkout &lt;filename&gt;# 恢复暂存区的所有文件到工作区$ git checkout .# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 检出结点, 标签$ git checkout[&lt;commitid&gt; | &lt;tag&gt;]## reset# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变, 软回退$ git reset [commit]# 重置暂存区与工作区，与上一次commit保持一致, 硬回退$ git reset --hard [commit]## revert# 生成一个撤销指定提交版本的新提交$ git revert &lt;commit_id&gt;# 新命令## restore &amp; switch# 主要还是为了分离 checkout的功能# 切换分支 = git checkout &lt;branchName&gt;$ git switch &lt;branchName&gt;# 创建并切换到新建分支 = git checkout -b &lt;newbranch&gt;$ git switch -c &lt;newBranch&gt;# 撤销工作区修改的文件 = git checkout &lt;fileName&gt;$ git restore &lt;fileName&gt;# 撤销暂存区的文件 = git reset &lt;fileName&gt;$ git restore --staged &lt;fileName&gt;","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://jingyu.life/tags/Git/"}]},{"title":"Docker 进阶篇之Compose","slug":"docker/compose","date":"2020-08-02T15:11:19.000Z","updated":"2020-08-09T05:49:57.401Z","comments":false,"path":"2020/08/02/docker/compose/","link":"","permalink":"https://jingyu.life/2020/08/02/docker/compose/","excerpt":"Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。","text":"Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。 简介Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。 Compose代码目前在 https://github.com/docker/compose 上开源。 安装与卸载 安装 Mac&#x2F;Windows Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。 Ubuntu 1、通过下载二进制包 123$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose 2、 pip安装 1$ sudo pip install -U docker-compose 3、bash补全命令 1$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 卸载1、删除二进制包文件 1$ sudo rm /usr/local/bin/docker-compose 2、pip移除 1$ sudo pip uninstall docker-compose 使用以及说明 术语首先介绍几个术语。 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。 可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。 命令 基本格式1$ docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...] 命令选项-f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 --x-networking 使用 Docker 的可拔插网络后端特性 --x-network-driver DRIVER 指定网络后端的驱动，默认为bridge --verbose 输出更多调试信息。 -v, --version 打印版本并退出。 build格式为 docker-compose build [options] [SERVICE...]。 构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。 选项包括： --force-rm 删除构建过程中的临时容器。 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。 --pull 始终尝试通过 pull 来获取更新版本的镜像。 config验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。 down此命令将会停止 up 命令所启动的容器，并移除网络 start格式为 docker-compose start [SERVICE...]。 启动已经存在的服务容器。 stop格式为 docker-compose stop [options] [SERVICE...]。 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时(默认为 10 秒)。 exec进入指定容器 images 列出 Compose 文件中包含的镜像。 kill 格式为 docker-compose kill [options] [SERVICE...]。 通过发送 SIGKILL 信号来强制停止服务容器。 logs 格式为 docker-compose logs [options] [SERVICE...]。 该命令在调试问题的时候十分有用。 pause 格式为 docker-compose pause [SERVICE...]。 暂停一个服务容器。 unpause格式为 docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 port格式为 docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 ps格式为 docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 pull格式为 docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 push推送服务依赖的镜像到 Docker 镜像仓库。 restart格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 rm格式为 docker-compose rm [options] [SERVICE...]。 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 选项： -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 run格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 选项： -d 后台运行容器。 --name NAME 为容器指定一个名字。 --entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=&quot;&quot; 指定运行容器的用户名或者 uid。 --no-deps 不自动启动关联的服务容器。 --rm 运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] 映射容器端口到本地主机。 --service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 scale格式为 docker-compose scale [options] [SERVICE=NUM...]。 设置指定服务运行的容器个数。 123# 通过 service=num 的参数来设置数量$ docker-compose scale web=3 db=2# 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 top查看各个服务容器内运行的进程。 up格式为 docker-compose up [options] [SERVICE...]。 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。 默认情况，docker-compose up 启动的容器都在前台，docker-compose up -d(生产环境下使用)，将会在后台启动并运行所有的容器。 如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate , 只会启动处于停止状态的容器，而忽略已经运行的服务; 如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 选项： -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 version格式为 docker-compose version。 打印版本信息。 Compose 模板文件​ 大部分指令跟 docker run 相关参数的含义都是类似的。默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。 每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。 build指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径） Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 12345version: &#x27;3&#x27;services: webapp: build: ./dir 也可以使用context 指令指定 Dockerfile 所在文件夹的路径， dockerfile 指令指定 Dockerfile 文件名， arg 指令指定构建镜像时的变量 123456789version: &#x27;3&#x27;services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 cache_from 指定构建镜像的缓存 12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop指定容器的内核能力（capacity）分配 command覆盖容器启动后默认执行的命令。 1command: echo &quot;hello world&quot; cgroup_parent指定父 cgroup 组，意味着将继承该组的资源限制。 12# 创建了一个 cgroup 组名称为 cgroups_1cgroup_parent: cgroups_1 container_name指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 1container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 devices指定设备映射关系。 12devices: - &quot;/dev/ttyUSB1:/dev/ttyUSB0&quot; depends_on解决容器的依赖、启动先后的问题。 1234567891011121314version: &#x27;3&#x27;services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 例子中会先启动 redis db 再启动 web , web 服务不会等待 redis db 「完全启动」之后才启动。 dns自定义 DNS 服务器。可以是一个值，也可以是一个列表。 12345dns: 8.8.8.8dns: - 8.8.8.8 - 114.114.114.114 dns_search配置 DNS 搜索域。可以是一个值，也可以是一个列表。 12345dns_search: example.comdns_search: - domain1.example.com - domain2.example.com tmpfs挂载一个 tmpfs 文件系统到容器。 1234tmpfs: /runtmpfs: - /run - /tmp env_file从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 123456env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env environment设置环境变量。可以使用数组或字典两种格式。 1234567environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET expose暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数 123expose: - &quot;3000&quot; - &quot;8000&quot; extra_hosts指定额外的 host 名称映射信息 123extra_hosts: - &quot;googledns:8.8.8.8&quot; - &quot;dockerhub:52.1.157.61&quot; 会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。 128.8.8.8 googledns52.1.157.61 dockerhub image指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 123image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd labels为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 1234labels: com.startupteam.description: &quot;webapp for a startup team&quot; com.startupteam.department: &quot;devops department&quot; com.startupteam.release: &quot;rc3 for v1.0&quot; logging配置日志选项。 123456789logging: # 目前支持三种日志驱动类型 json-file syslog none driver: syslog options: syslog-address: &quot;tcp://192.168.0.42:123&quot; # options: # max-size: &quot;200k&quot; # max-file: &quot;10&quot; network_mode设置网络模式。使用和 docker run 的 --network 参数一样的值。 12345network_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot; networks配置容器连接的网络。 1234567891011version: &quot;3&quot;services: some-service: networks: - some-network - other-networknetworks: some-network: other-network: pid跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。 1pid: &quot;host&quot; ports暴露端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 12345ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; volumes数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式 （HOST:CONTAINER:ro）。 1234volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro 如果路径为数据卷名称，必须在文件中配置数据卷。 12345678910version: &quot;3&quot;services: my_src: image: mysql:8.0 volumes: - mysql_data:/var/lib/mysqlvolumes: mysql_data:","categories":[{"name":"运维","slug":"运维","permalink":"https://jingyu.life/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://jingyu.life/tags/Docker/"}]},{"title":"Docker 基础篇","slug":"docker/basic","date":"2020-07-31T08:40:08.000Z","updated":"2020-08-01T09:22:24.592Z","comments":false,"path":"2020/07/31/docker/basic/","link":"","permalink":"https://jingyu.life/2020/07/31/docker/basic/","excerpt":"Docker是一种运行在Linux和Windows上的软件，用于创建、管理和编排容器","text":"Docker是一种运行在Linux和Windows上的软件，用于创建、管理和编排容器 安装 Ubuntu 移除旧版本 123$ sudo apt-get remove docker \\ docker-engine \\ docker.io Apt 安装 12345678910111213141516171819202122232425262728# 安装https传输的软件包和ca证书$ sudo apt-get update$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common # 添加软件源的 GPG 密钥$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 官方源# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 向 source.list 中添加 Docker 软件源$ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 官方源# $ sudo add-apt-repository \\# &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable&quot; Docker CE 安装、启动 123456789101112# 安装$ sudo apt-get update$ sudo apt-get install docker-ce# 也可以通过脚本自动化安装$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun# $ sudo sh get-docker.sh --mirror AzureChinaCloud# 启动$ sudo systemctl enable docker$ sudo systemctl start docker 建立docker用户组 1234# 建立用户组$ sudo groupadd docker# 将当前用户添加到docker组$ sudo usermod -aG docker $USER MacOS HomeBrew 1$ brew cask install docker 手动下载安装 如果需要手动下载，请点击以下链接下载 Stable 或 Edge 版本的 Docker Desktop for Mac。 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间需要输入用户密码）。 镜像 搜索1$ docker search ubuntu 获取镜像123# 格式 docker (image) pull &lt;Registry&gt;/&lt;userName of Orgnization&gt;/&lt;Repository&gt;:&lt;Tag&gt;# eg$ docker pull ubuntu:latest 列举镜像12345678# 列举格式 $ docker images &lt;repository&gt;:&lt;tag&gt;# filter 参数过滤， 列举所有tag 为latest的镜像 (dangling, before, since, label, reference)$ docker image ls --filter reference=&quot;*:latest&quot;# 格式化显示, 注意格式(大小写、标点)$ docker images --format &quot;&#123;&#123;.Repository&#125;&#125;: &#123;&#123;.Size&#125;&#125;&quot;$ docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;# 删除悬虚镜像$ docker image prune 删除本地镜像12345# 删除格式， 其中镜像是镜像ID(长或短)、镜像名、镜像摘要$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]# 删除所有名为redis的镜像$ docker rmi $(docker image ls -q redis) 更新镜像当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 123# 产看容器内的变化# 格式 docker diff &lt;容器ID或容器名&gt;$ docker diff webserver 1234567891011121314 # 格式 $ docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] # 例如, 在nginx容器中修改内容后 $ docker commit \\ --author &quot;jingyucute@gmail.com&quot; \\ --message &quot;update content&quot; \\ webserver \\ nginx:v2 # 或者简写$ docker commit \\ -a=&quot;jingyucute@gmail.com&quot; \\ -m=&quot;update content&quot; \\ webserver \\ nginx:v2 123# 产看镜像内的提交记录# 格式 docker history &lt;仓库名&gt;[:&lt;标签&gt;$ docker history nginx:v2 特别注意 docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。 使用Dockerfile制作镜像123456789101112131415# 格式 docker build [选项] &lt;上下文路径/URL/-&gt;$ docker build -t &lt;repository&gt;:&lt;tag&gt; .# 直接从Git repo中构建$ docker build https://github.com/twang2218/gitlab-ce-zh.git# 用给定的 tar 压缩包构建， 下载后会自动解压$ docker build http://server/context.tar.gz# 标准输入构建$ docker build - &lt; context.tar.gz$ docker build - &lt; Dockerfile$ cat Dockerfile | docker build - 容器 查看123# 查看正在运行的容器, 加上-a参数表示查看所有的容器(包括退出的)$ docker container ls [-a]$ docker ps [-a] 启动1234567891011121314151617# 从镜像中创建并启动一个容器 , 参数自己查吧# 格式 docker &lt;container&gt; run [--options]# 交互式运行ubuntu容器# -i: 交互式操作。# -t: 终端。# ubuntu: ubuntu 镜像。# /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash$ docker run -it ubuntu --name myOS /bin/bash# 守护态运行一个容器 # 格式 docker &lt;container&gt; run -d $ docker run -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;# 启动一个停止了的容器# 格式 docker &lt;container&gt; start &lt;Container-name-or-ID&gt;$ docker start myOS 重启12# 格式 docker &lt;container&gt; restart &lt;Container-name-or-ID&gt;$ docker restart myOS 查看容器输出12# 格式 docker &lt;container&gt; logs &lt;Container-name-or-ID&gt;$ docker logs myOS 停止12# 格式 docker &lt;container&gt; stop &lt;Container-name-or-ID&gt;$ docker stop myOS 删除123456# 删除的容器不能是运行状态，可以先停止再删除, 也可以通过加上 -f 参数强删(不推荐)# 格式 docker container rm &lt;Container-name-or-ID&gt; [-f]$ docker rm &lt;Container-name-or-ID&gt;# 清楚所有停止状态的容器$ docker container prune 进入容器123456789101112# 两种方式, 推荐使用方式二# 方式一 docker attach &lt;Container-name-or-ID&gt;# 这种方式退出终端，会导致容器停止$ docker attach myOS# 方式一 docker attach &lt;Container-name-or-ID&gt;# 这种方式退出终端，会导致容器停止$ docker attach myOS# 方式二 docker exec -it &lt;Container-name-or-ID&gt; bash# 这种方式退出终端，容器不会停止$ docker exec -it myOS bash Dockerfile参数说明 FROM所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 12FROM nginx... RUNRUN 指令是用来执行命令行命令的。通常有两种形式： ​ shell格式 RUN &lt;命令&gt; (常用格式) 1RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html ​ exec格式 RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] . 这种形式好比函数调用 123RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] # ====RUN ./test.php dev offline 注意 这里的RUN要尽量少， 多了会导致镜像臃肿， 因为镜像是按照层来构建的，一个RUN就是一层。所以可以使用 &amp;&amp; 来链接命令，使用 \\来换行 举个例子： 12345678910111213141516171819202122232425FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install# ---------------------------------------------------------&gt; FROM debian:stretchRUN buildDeps=&#x27;gcc libc6-dev make wget&#x27; \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps COPYCOPY指令将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置 123456# 格式 COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;# COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] COPY hom?.txt /mydir/# 改变文件的所属用户和用户组 --chown=&lt;user&gt;:&lt;group&gt;COPY --chown=55:mygroup files* /mydir/ ADDADD 指令和 COPY 的格式和性质基本一致(同样需求下， 推荐使用COPY)。 ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 12# 改变文件的所属用户和用户组 --chown=&lt;user&gt;:&lt;group&gt;ADD --chown=55:mygroup files* /mydir/ CMDCMD 指令的格式和 RUN 相似。 CMD 在docker run 时运行。 RUN 是在 docker build。 CMD也有两种形式 1234567# shell 格式：CMD &lt;命令&gt;# exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]CMD echo $HOME# ====CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ] Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。 123# CMD service nginx start# 这个命令是将nginx作为后台服务来运行的， 应该写为一下形式CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] ENTRYPOINTENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。就可以理解为&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 1# 格式 ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] ENV设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 12345# 格式 ENV &lt;key&gt; &lt;value&gt; # ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \\ &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; ARGARG 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。 1# 格式 ARG &lt;参数名&gt;[=&lt;默认值&gt;] 该默认值可以在构建命令 docker build 中用 --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。 VOLUME容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 123# 格式 VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]# VOLUME &lt;路径&gt;VOLUME /data 1docker run -d -v mydata:/data 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 EXPOSEEXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 1# 格式 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 1# 格式 WORKDIR &lt;工作目录路径&gt; 谈一下误区 初学者将Dockerfile 等同于 Shell 脚本来书写，会出现一下错误 12RUN cd /appRUN echo &quot;hello&quot; &gt; world.txt 将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。 原因: 在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器 每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 USREUSER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份(用户和用户组必须提前已经存在)。 1# 格式 USER &lt;用户名&gt;[:&lt;用户组&gt;]","categories":[{"name":"运维","slug":"运维","permalink":"https://jingyu.life/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://jingyu.life/tags/Docker/"}]},{"title":"常用工具网址","slug":"tools/tool-assistant","date":"2020-07-28T06:34:06.000Z","updated":"2023-03-07T13:16:29.011Z","comments":false,"path":"2020/07/28/tools/tool-assistant/","link":"","permalink":"https://jingyu.life/2020/07/28/tools/tool-assistant/","excerpt":"这里记录一些常用的工具、网址等等","text":"这里记录一些常用的工具、网址等等 网址 我告诉你 简易图标制作 svg简易制作 一个很有意思的小站 工具 Typora V2rayU","categories":[{"name":"工具","slug":"工具","permalink":"https://jingyu.life/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Helper","slug":"Helper","permalink":"https://jingyu.life/tags/Helper/"}]},{"title":"nvm 使用说明","slug":"node/nvm-usage","date":"2020-07-15T04:04:41.000Z","updated":"2023-03-10T10:47:10.285Z","comments":false,"path":"2020/07/15/node/nvm-usage/","link":"","permalink":"https://jingyu.life/2020/07/15/node/nvm-usage/","excerpt":"简介 Nvm （Node Version Manager） 是node.js 的版本管理器，用它可以方便的在机器上安装并维护多个node版本。","text":"简介 Nvm （Node Version Manager） 是node.js 的版本管理器，用它可以方便的在机器上安装并维护多个node版本。 1、安装和更新脚本安装 下载并执行 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash 或者 1wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash 然后配置环境变量，将下面的内容添加到配置文件(~/.bash_profile，~/.zshrc，~/.profile，或~/.bashrc) 12export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm git 安装 1、克隆远程仓库到本地 先 cd ~ 切换到家目录， 然后执行git clone https://github.com/nvm-sh/nvm.git .nvm 2、进入到.nvm目录，切换到最近的版本 12cd ~/.nvmgit checkout v0.35.3 3、 激活nvm 1bash nvm.sh 4、 配置环境变量，文件位置同上，导入内容如下 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion nvm更新 1、切换到$NVM_DIR (上面在环境变量中配置过了) 2、拉取最新的提交节点 3、切换到最新的版本 4、激活新版本 可以直接在命令行中执行一下内容 12345( cd &quot;$NVM_DIR&quot; git fetch --tags origin git checkout `git describe --abbrev=0 --tags --match &quot;v[0-9]*&quot; $(git rev-list --tags --max-count=1)`) &amp;&amp; bash &quot;$NVM_DIR/nvm.sh&quot; 2、相关使用123456789101112131415161718192021222324252627282930# 查看已经安装的版本nvm ls# 查看可以安装的所有版本nvm ls-remote# 查看所有长期支持版本（LTS）nvm ls-remote --lts# 查看最新ltsnvm version-remote --lts nvm version-remote lts/erbium# 安装最新ltsnvm install --lts# 安装或卸载指定node版本nvm install v12.18.2 nvm uninstall v12.18.2# 使用nodenvm use v12.18.2# 设置或取消别名nvm alias product v12.18.2 nvm unalias product# 安装io.jsnvm install iojs# 查看node安装位置nvm which v12.18.2 本文参考地址 https://github.com/nvm-sh/nvm","categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://jingyu.life/tags/Node/"},{"name":"Nvm","slug":"Nvm","permalink":"https://jingyu.life/tags/Nvm/"}]},{"title":"Typora快捷键使用(Mac)","slug":"tools/typora-usage","date":"2020-06-24T16:00:00.000Z","updated":"2023-03-07T13:16:29.012Z","comments":false,"path":"2020/06/25/tools/typora-usage/","link":"","permalink":"https://jingyu.life/2020/06/25/tools/typora-usage/","excerpt":"简介 刚开始搭建自己的博客， 学习了一下Markdown语法和Typora，这里记录了一下相关快捷键的使用。","text":"简介 刚开始搭建自己的博客， 学习了一下Markdown语法和Typora，这里记录了一下相关快捷键的使用。 1、基本操作1.1 生成目录 语法 1[toc] 效果图 [toc] 1.2 标题 语法 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 快捷键 Command + [1, 2, 3, 4, 5, 6] 分别对应几级标题 1.3 引用 语法 123&gt; 引用内容1 &gt;&gt; 引用内容2 &gt;&gt; 引用内容3 快捷键 Command + Option + Q 效果图 引用内容1 引用内容2 引用内容3 1.4 文本居中 语法 1&lt;center&gt;居中文本&lt;/center&gt; 效果图 居中文本 2 、code使用2.1 单行代码 语法 12`String str = &quot;Hello Typora&quot;;```String str = &quot;Hello Typora&quot;;`` 效果图 String str = &quot;Hello Typora&quot;; 2.2 多行代码 语法 12输入 ```[language] + enter或者 ``` + enter , 然后选择语言类型 快捷键 Command + Option + C 效果图 1234int a = 1;int b = 2;int c = 3;count&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;, b=&quot;&lt;&lt;b&lt;&lt;&quot;, c=&quot;&lt;&lt;c&lt;&lt;endl; 3、列表3.1 无序列表 语法 123* (+) [space]- (+) [space]+ (+) [space] 快捷键 Command + Option + U 效果图 类别一 类别二 类别三 3.2 有序列表 语法 1231. (+) [space]2. (+) [space]3. (+) [space] 快捷键 Command + Option + O 效果图 类别1 类别2 类别3 3.3 任务列表 语法 123形式: - [ ] 文本 为未选中文本 - [x] 文本 为选中文本注意: -和[之间有空格, [和]之间有空格, ]和文本之间有空格 快捷键 Command + Option + X 效果图 钓鱼 编程 散步 游戏 电影 3.4 表格 语法 12345|姓名|性别|年龄|手机号||:---|:--:|:--:|:---:||张三|男|21|18975346876||李四|女|23|17789548964||王五|男|25|15876513546| 快捷键 Command + Option + T 效果图 姓名 性别 年龄 手机号 张三 男 21 18975346876 李四 女 23 17789548964 王五 男 25 15876513546 4、链接4.1 图片 语法 本地图片 1直接拖进来 网络图片 1![杭州西湖.jpg](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593110861170&amp;di=6651925eaab36bfeb23347aa51a12cb7&amp;imgtype=0&amp;src=http%3A%2F%2Fa3.att.hudong.com%2F14%2F75%2F01300000164186121366756803686.jpg) 效果图 本地 网络 4.2 文本链接 语法 不显示链接网址 1[百度](https://www.baidu.com) 只显示链接url 1&lt;https://www.baidu.com&gt; 快捷键 Command + K 效果图 不显示地址 百度 只显示url https://www.baidu.com 5、其它快捷键5.1 斜体 语法 12*斜体文字1*_斜体文字2_ 快捷键 Command + I 效果图 斜体文字1 斜体文字2 5.2 粗体 语法 12**粗体文字1**__粗体文字2__ 快捷键 Command + B 效果图 粗体文字1 粗体文字2 5.3 加粗斜体 语法 12***加粗斜体文字1***___加粗斜体文字2___ 效果图 加粗斜体文字1 加粗斜体文字2 5.4 下划线 语法 1&lt;u&gt;下划线文字&lt;/u&gt; 快捷键 Command + U 效果图 下划线文字 5.5 删除线 语法 1~~删除文字~~ 快捷键 Control + Shift + &#96; 效果图 删除文字 5.6 分割线 语法 12--- (+) [enter]*** (+) [enter] 快捷键 Command (+) Option (+) - 效果图 5.7 脚注 语法 12Typora1[^1]Typora2[^2] 快捷键 Command + Option + R 效果图 Typora^1 Typora2^2 5.8 符号输入 语法 123456789101112\\\\ 反斜线\\` 反引号\\* 星号\\_ 底线\\&#123; \\&#125; 花括号\\[ \\] 方括号\\( \\) 括弧\\# 井字号\\+ 加号\\- 减号\\. 英文句点\\! 惊叹号 效果图 \\ 5.9 特殊字符 语法 1234567891011121314151617181920&amp;copy; 版权 &amp;reg; 注册商标&amp;trade; 商标&amp;nbsp; 空格&amp;amp; 和号&amp;quot; 引号&amp;apos; 撇号&amp;lt; 小于号&amp;gt; 大于号&amp;ne; 不等号&amp;le; 小于等于&amp;ge; 大于等于&amp;cent; 分&amp;pound; 磅&amp;euro; 欧元&amp;yen; 元&amp;sect; 节&amp;times; 乘号&amp;divide; 除号&amp;plusmn; 正负号 效果图 &amp;copy; &amp;pound; &amp;apos; &amp;euro; 5.10 表情 语法 1:smiley: 效果图 :smile: :unamused:","categories":[{"name":"工具","slug":"工具","permalink":"https://jingyu.life/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://jingyu.life/tags/Typora/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://jingyu.life/tags/MarkDown/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/"},{"name":"环境","slug":"开发/环境","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E7%8E%AF%E5%A2%83/"},{"name":"前端","slug":"开发/前端","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","permalink":"https://jingyu.life/categories/%E5%B7%A5%E5%85%B7/"},{"name":"数据库","slug":"开发/数据库","permalink":"https://jingyu.life/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"运维","slug":"运维","permalink":"https://jingyu.life/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://jingyu.life/tags/Go/"},{"name":"Gvm","slug":"Gvm","permalink":"https://jingyu.life/tags/Gvm/"},{"name":"Node","slug":"Node","permalink":"https://jingyu.life/tags/Node/"},{"name":"ES","slug":"ES","permalink":"https://jingyu.life/tags/ES/"},{"name":"VsCode","slug":"VsCode","permalink":"https://jingyu.life/tags/VsCode/"},{"name":"Promise","slug":"Promise","permalink":"https://jingyu.life/tags/Promise/"},{"name":"Hexo","slug":"Hexo","permalink":"https://jingyu.life/tags/Hexo/"},{"name":"Redis","slug":"Redis","permalink":"https://jingyu.life/tags/Redis/"},{"name":"Mysql","slug":"Mysql","permalink":"https://jingyu.life/tags/Mysql/"},{"name":"Git","slug":"Git","permalink":"https://jingyu.life/tags/Git/"},{"name":"Docker","slug":"Docker","permalink":"https://jingyu.life/tags/Docker/"},{"name":"Helper","slug":"Helper","permalink":"https://jingyu.life/tags/Helper/"},{"name":"Nvm","slug":"Nvm","permalink":"https://jingyu.life/tags/Nvm/"},{"name":"Typora","slug":"Typora","permalink":"https://jingyu.life/tags/Typora/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://jingyu.life/tags/MarkDown/"}]}